<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NetBox</name>
    </assembly>
    <members>
        <member name="T:NetBox.Application.Ascii85">
            <summary>
            C# implementation of ASCII85 encoding. 
            Based on C code from http://www.stillhq.com/cgi-bin/cvsweb/ascii85/
            </summary>
            <remarks>
            Jeff Atwood
            http://www.codinghorror.com/blog/archives/000410.html
            </remarks>
        </member>
        <member name="F:NetBox.Application.Ascii85.PrefixMark">
            <summary>
            Prefix mark that identifies an encoded ASCII85 string
            </summary>
        </member>
        <member name="F:NetBox.Application.Ascii85.SuffixMark">
            <summary>
            Suffix mark that identifies an encoded ASCII85 string
            </summary>
        </member>
        <member name="F:NetBox.Application.Ascii85.LineLength">
            <summary>
            Maximum line length for encoded ASCII85 string; 
            set to zero for one unbroken line.
            </summary>
        </member>
        <member name="M:NetBox.Application.Ascii85.Decode(System.String,System.Boolean)">
            <summary>
            Decodes an ASCII85 encoded string into the original binary data
            </summary>
            <param name="s">ASCII85 encoded string</param>
            <param name="enforceMarks">enforce marks</param>
            <returns>byte array of decoded binary data</returns>
        </member>
        <member name="M:NetBox.Application.Ascii85.Encode(System.Byte[],System.Boolean)">
            <summary>
            Encodes binary data into a plaintext ASCII85 format string
            </summary>
            <param name="ba">binary data to encode</param>
            <param name="enforceMarks">enforce marks</param>
            <returns>ASCII85 encoded string</returns>
        </member>
        <member name="F:NetBox.Application.ByteFormat.Standard.Si">
            <summary>
             International System of Units
            </summary>
        </member>
        <member name="F:NetBox.Application.ByteFormat.Standard.Iec">
            <summary>
            International Electrotechnical Commission
            </summary>
        </member>
        <member name="M:NetBox.Application.ByteFormat.ToString(System.Int64,NetBox.Application.ByteFormat.Standard)">
            <summary>
            Returns the best formatted string representation of a byte value
            </summary>
            <param name="bytes">number of bytes</param>
            <param name="st"></param>
            <returns>formatted string</returns>
        </member>
        <member name="M:NetBox.Application.ByteFormat.ToString(System.Int64,NetBox.Application.ByteFormat.Standard,System.String)">
            <summary>
            Returns the best formatted string representation of a byte value
            </summary>
            <param name="bytes">number of bytes</param>
            <param name="st"></param>
            <param name="customFormat">Defines a custom numerical format for the conversion.
            If this parameters is null or empty the default format will be used 0.00</param>
            <returns>formatted string</returns>
        </member>
        <member name="T:NetBox.Application.WebUtility">
            <summary>
            This class is ported from .NET 4.6 to support URL encoding/decoding functionality which is missing in .NET Standard
            </summary>
        </member>
        <member name="T:NetBox.Caching.LazyVar`1">
            <summary>
            Implements a lazy value i.e. that can expire in future
            </summary>
            <typeparam name="T">Type of an object to wrap in</typeparam>
        </member>
        <member name="M:NetBox.Caching.LazyVar`1.#ctor(System.TimeSpan,System.Func{System.Threading.Tasks.Task{`0}})">
            <summary>
            Creates an instance of a lazy variable with time-to-live value
            </summary>
            <param name="timeToLive">Time to live. Setting to <see cref="F:System.TimeSpan.Zero"/> disables caching completely</param>
            <param name="renewFunc"></param>
        </member>
        <member name="M:NetBox.Caching.LazyVar`1.#ctor(System.TimeSpan,System.Func{`0})">
            <summary>
            Creates an instance of a lazy variable with time-to-live value
            </summary>
            <param name="timeToLive">Time to live. Setting to <see cref="F:System.TimeSpan.Zero"/> disables caching completely</param>
            <param name="renewFunc"></param>
        </member>
        <member name="M:NetBox.Caching.LazyVar`1.GetValueAsync">
            <summary>
            Gets the values, renewing it if necessary
            </summary>
            <returns>Value</returns>
        </member>
        <member name="M:NetBox.Caching.LazyVar`1.GetValue">
            <summary>
            Gets the values, renewing it if necessary
            </summary>
            <returns>Value</returns>
        </member>
        <member name="T:NetBox.Collections.CallbackList`1">
            <summary>
            Calls back on common list operations, allowing to get a notification without subclassing the whole plethora of methods.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NetBox.Collections.CallbackList`1.OnAdd">
            <summary>
            Called when an element is about to be added. You have a chance to override which element value is to be added by
            returning an element different from the one that is passed in.
            </summary>
        </member>
        <member name="P:NetBox.Collections.CallbackList`1.OnInsert">
            <summary>
            Called when an element is about to be inserted. You have a chance to override which element is to be inserted by
            returning an element different from the one that is passed in.
            </summary>
        </member>
        <member name="P:NetBox.Collections.CallbackList`1.OnRemove">
            <summary>
            Called when an element is removed
            </summary>
        </member>
        <member name="P:NetBox.Collections.CallbackList`1.OnRemoveAt">
            <summary>
            Called when an element is removed at a specific position
            </summary>
        </member>
        <member name="P:NetBox.Collections.CallbackList`1.OnClear">
            <summary>
            Called when the list is cleared
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.#ctor">
            <summary>
            Creates a new instance of <see cref="T:NetBox.Collections.CallbackList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates a new instance of <see cref="T:NetBox.Collections.CallbackList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:NetBox.Collections.CallbackList`1"/>
            </summary>
        </member>
        <member name="P:NetBox.Collections.CallbackList`1.Item(System.Int32)">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="P:NetBox.Collections.CallbackList`1.Count">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="P:NetBox.Collections.CallbackList`1.IsReadOnly">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.Add(`0)">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.Clear">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.Contains(`0)">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.GetEnumerator">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.IndexOf(`0)">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.Insert(System.Int32,`0)">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.Remove(`0)">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.RemoveAt(System.Int32)">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="M:NetBox.Collections.CallbackList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Overriden from <see cref="T:System.Collections.Generic.IList`1"/>
            </summary>
        </member>
        <member name="T:NetBox.Collections.ObjectPool`1">
            <summary>
            Implement an object pool which allows object to be reusable and cached for a specific amount of time.
            This class is thread safe.
            </summary>
            <typeparam name="T">Type of object to be pooled</typeparam>
        </member>
        <member name="M:NetBox.Collections.ObjectPool`1.#ctor(System.Func{`0},System.Action{`0},System.Int32,System.TimeSpan)">
            <summary>
            
            </summary>
            <param name="createFunction">
            A function responsible for creating new instances of an object. It must  return a new instance every
            time and is required. You should not use any form of instance caching.</param>
            <param name="destroyFunction">
            When specified is called on the object instance. You are responsible for a proper cleanup as object
            pool only removes it from internal instance collection.</param>
            <param name="capacity">
            Maximum capacity of this pool specifying how many instances the pool
            can hold as a maximum.
            </param>
            <param name="maxAge">
            Specifies how long the object can live. When object is used for more than this time it's destroyed
            by removing from internal cache and calling the destroy function when specified.
            </param>
        </member>
        <member name="M:NetBox.Collections.ObjectPool`1.GetInstance">
            <summary>
            Gets an available instance from the object pool by creating a new one, reusing existing one,
            or waiting for an available one.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetBox.Collections.ObjectPool`1.HasFreeInstance">
            <summary>
            Returns true if object pool has instances in the cache which have not been used yet.
            </summary>
        </member>
        <member name="P:NetBox.Collections.ObjectPool`1.InstanceCount">
            <summary>
            Returns the number of instances in use
            </summary>
        </member>
        <member name="M:NetBox.Collections.ObjectPool`1.ReleaseInstance(`0)">
            <summary>
            Returns instance to the object pool so it can be reused
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:NetBox.Collections.ObjectPool`1.Dispose">
            <summary>
            Releases all object instances and calls the destroy function on each of them if you have specified one.
            </summary>
        </member>
        <member name="T:NetBox.Data.DynamicValue">
            <summary>
            Represents a primitive value which can be constructed from anything and converted to anything.
            "Anything" is to the best effort and will be extended constantly.
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.#ctor(System.Object)">
            <summary>
            Constructs an instance of DynamicValue
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:NetBox.Data.DynamicValue.OriginalValue">
            <summary>
            Original value
            </summary>
        </member>
        <member name="P:NetBox.Data.DynamicValue.OriginalType">
            <summary>
            Original type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.GetValue(System.Type)">
            <summary>
            Gets value of specified type
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Data.DynamicValue.GetValue``1">
            <summary>
            Gets value of specified type
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Int32">
            <summary>
            Implicitly converts to int data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Int32)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from int to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.UInt32">
            <summary>
            Implicitly converts to uint data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.UInt32)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from uint to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Int64">
            <summary>
            Implicitly converts to long data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Int64)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from long to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.UInt64">
            <summary>
            Implicitly converts to ulong data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.UInt64)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from ulong to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Double">
            <summary>
            Implicitly converts to double data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Double)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from double to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Guid">
            <summary>
            Implicitly converts to Guid data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Guid)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from Guid to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.DateTime">
            <summary>
            Implicitly converts to DateTime data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.DateTime)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from DateTime to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.DateTimeOffset">
            <summary>
            Implicitly converts to DateTimeOffset data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.DateTimeOffset)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from DateTimeOffset to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.String">
            <summary>
            Implicitly converts to string data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.String)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from string to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Byte[]">
            <summary>
            Implicitly converts to byte[] data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Byte[])~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from byte[] to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Boolean">
            <summary>
            Implicitly converts to bool data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Boolean)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from bool to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Byte">
            <summary>
            Implicitly converts to byte data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Byte)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from byte to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.SByte">
            <summary>
            Implicitly converts to sbyte data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.SByte)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from sbyte to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Char">
            <summary>
            Implicitly converts to char data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Char)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from char to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Decimal">
            <summary>
            Implicitly converts to decimal data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Decimal)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from decimal to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Single">
            <summary>
            Implicitly converts to float data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Single)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from float to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.Int16">
            <summary>
            Implicitly converts to short data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.Int16)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from short to an instance of DynamicValue
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(NetBox.Data.DynamicValue)~System.UInt16">
            <summary>
            Implicitly converts to ushort data type
            </summary>
        </member>
        <member name="M:NetBox.Data.DynamicValue.op_Implicit(System.UInt16)~NetBox.Data.DynamicValue">
            <summary>
            Implicitly converts from ushort to an instance of DynamicValue
            </summary>
        </member>
        <member name="T:NetBox.Extensions.AssemblyExtensions">
            <summary>
            <see cref="T:System.Reflection.Assembly"/> extension methods
            </summary>
        </member>
        <member name="M:NetBox.Extensions.AssemblyExtensions.ProductVersion(System.Reflection.Assembly)">
            <summary>
            Gets the product version (set by [assembly:Version] attribute)
            </summary>
        </member>
        <member name="M:NetBox.Extensions.AssemblyExtensions.GetSameFolderEmbeddedResourceFile``1(System.Reflection.Assembly,System.String)">
            <summary>
            Reads embedded resource file which lies next to a type specified in TTypeNextToFile 
            </summary>
            <param name="assembly">Assembly where the resource file resides, usually it's Assembly.GetExecutingAssembly()</param>
            <param name="fileName">name of the file, i.e. "myresource.txt"</param>
            <returns>File stream if it exists, otherwise null</returns>
        </member>
        <member name="M:NetBox.Extensions.AssemblyExtensions.GetSameFolderEmbeddedResourceFileAsText``1(System.Reflection.Assembly,System.String)">
            <summary>
            Reads embedded resource file as text
            </summary>
            <typeparam name="TTypeNextToFile">This type must reside in the same folder as resource file</typeparam>
            <param name="assembly">Assembly where the resource file resides, usually it's Assembly.GetExecutingAssembly()</param>
            <param name="fileName">name of the file, i.e. "myresource.txt"</param>
            <returns>File stream if it exists, otherwise null</returns>
        </member>
        <member name="M:NetBox.Extensions.AssemblyExtensions.GetSameFolderEmbeddedResourceFileAsLines``1(System.Reflection.Assembly,System.String)">
            <summary>
            Reads embedded resource file as array of lines
            </summary>
            <typeparam name="TTypeNextToFile">This type must reside in the same folder as resource file</typeparam>
            <param name="assembly">Assembly where the resource file resides, usually it's Assembly.GetExecutingAssembly()</param>
            <param name="fileName">name of the file, i.e. "myresource.txt"</param>
            <returns>File stream if it exists, otherwise null</returns>
        </member>
        <member name="M:NetBox.Extensions.AssemblyExtensions.FileVersion(System.Reflection.Assembly)">
            <summary>
            Gets the file version (set by [assembly:FileVersion] attribute)
            </summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="T:NetBox.Extensions.ByteArrayExtensions">
            <summary>
            Byte array extensions methods
            </summary>
        </member>
        <member name="M:NetBox.Extensions.ByteArrayExtensions.ToHexString(System.Byte[])">
            <summary>
            Converts byte array to hexadecimal string
            </summary>
        </member>
        <member name="M:NetBox.Extensions.ByteArrayExtensions.GetHash(System.Byte[],NetBox.HashType)">
            <summary>
            Calculates a hash on byte array
            </summary>
        </member>
        <member name="M:NetBox.Extensions.ByteArrayExtensions.Gzip(System.Byte[])">
            <summary>
            Gzips sequence of bytes
            </summary>
        </member>
        <member name="M:NetBox.Extensions.ByteArrayExtensions.Ungzip(System.Byte[])">
            <summary>
            Ungzips sequence of bytes
            </summary>
        </member>
        <member name="M:NetBox.Extensions.ByteArrayExtensions.IsGzipped(System.Byte[])">
            <summary>
            Checks the beginning of the byte array for a GZIP header
            </summary>
        </member>
        <member name="T:NetBox.Extensions.DateTimeExtensions">
            <summary>
            <see cref="T:System.DateTime"/> extension methods
            </summary>
        </member>
        <member name="M:NetBox.Extensions.DateTimeExtensions.RoundToDay(System.DateTime)">
            <summary>
            Strips time from the date structure
            </summary>
        </member>
        <member name="M:NetBox.Extensions.DateTimeExtensions.EndOfDay(System.DateTime)">
            <summary>
            Changes to the end of day time, i.e. hours, minutes and seconds are changed to 23:59:59
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.DateTimeExtensions.RoundToMinute(System.DateTime,System.Int32,System.Boolean)">
            <summary>
            Rounds to the closest minute
            </summary>
            <param name="time">Input date</param>
            <param name="round">Closest minute i.e. 15, 30, 45 etc.</param>
            <param name="roundLeft">Whether to use minimum or maximum value. For example
            when time is 13:14 and rounding is to every 15 minutes, when this parameter is true
            the result it 13:00, otherwise 13:15</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.DateTimeExtensions.RoundToSecond(System.DateTime)">
            <summary>
            Strips off details after seconds
            </summary>
            <param name="time"></param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.DateTimeExtensions.IsToday(System.DateTime)">
            <summary>
            Returns true if the date is today's date.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.DateTimeExtensions.IsTomorrow(System.DateTime)">
            <summary>
            Returns true if the date is tomorrow's date.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.DateTimeExtensions.ToHourMinuteString(System.DateTime)">
            <summary>
            Returns date in "HH:mm" format
            </summary>
        </member>
        <member name="M:NetBox.Extensions.DateTimeExtensions.ToIso8601DateString(System.DateTime)">
            <summary>
            Formats date in ISO 8601 format
            </summary>
        </member>
        <member name="T:NetBox.Extensions.DictionaryExtensions">
            <summary>
            IDictionary extensions
            </summary>
        </member>
        <member name="M:NetBox.Extensions.DictionaryExtensions.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Adds all elements from source to target
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
            <param name="source">Source dictionary to get the values from</param>
            <param name="target">Target dictionary to add values to</param>
        </member>
        <member name="M:NetBox.Extensions.DictionaryExtensions.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>
            Gets element by key if it exists in the dictionary, otherwise calls specifed method to
            create a new element and adds it back to the dictionary
            </summary>
            <typeparam name="TKey">Key type</typeparam>
            <typeparam name="TValue">Value type</typeparam>
            <param name="target">Target dictionary</param>
            <param name="key">Key to search on</param>
            <param name="createValue">Method used to create a new value</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.DictionaryExtensions.JsonSerialise(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            Serialises key-value dictionary using embedded JSON serialiser with zero dependencies.
            This is using source code from https://github.com/facebook-csharp-sdk/simple-json.
            </summary>
            <param name="dictionary">Dictionary to serialise</param>
            <returns>JSON string</returns>
        </member>
        <member name="T:NetBox.Extensions.EnumerableEx">
            <summary>
            Enumerable extras
            </summary>
        </member>
        <member name="M:NetBox.Extensions.EnumerableEx.MultiIterate``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Iterates over two <see cref="T:System.Collections.IEnumerable"/> until one of them reaches the end of elements
            </summary>
            <typeparam name="TFirst">Types of elements in the first sequence</typeparam>
            <typeparam name="TSecond">Types of elements in the second sequence</typeparam>
            <param name="first">First sequence</param>
            <param name="second">Second sequence</param>
            <returns>Sequence of tuples from the first and second sequences</returns>
        </member>
        <member name="T:NetBox.Extensions.EnumerableExtensions">
            <summary>
            <see cref="T:System.IEquatable`1"/> extension methods
            </summary>
        </member>
        <member name="M:NetBox.Extensions.EnumerableExtensions.Chunk``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Split sequence in batches of specified size
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="source">Enumeration source</param>
            <param name="chunkSize">Size of the batch chunk</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs a specific action on each element of the sequence
            </summary>
        </member>
        <member name="M:NetBox.Extensions.EnumerableExtensions.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            ICollection extension brining the useful AddRange from List
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="source"></param>
        </member>
        <member name="M:NetBox.Extensions.EnumerableExtensions.InferType(System.String[])">
            <summary>
            Tries to guess the type of data contained in the strings
            </summary>
            <param name="data">The data.</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.EnumerableExtensions.InferType(System.String[],System.Collections.IList@)">
            <summary>
            Tries to guess the type of data contained in the strings
            </summary>
            <param name="data">The data.</param>
            <param name="values">Where to put the result values</param>
            <returns></returns>
        </member>
        <member name="T:NetBox.Extensions.EnumExtensions">
            <summary>
            Enum extensions methods
            </summary>
        </member>
        <member name="M:NetBox.Extensions.EnumExtensions.GetEnumTag(System.Enum)">
            <summary>
            Gets attribute value for enums marked with <see cref="T:NetBox.Model.EnumTagAttribute"/>
            </summary>
            <param name="enumValue">Enumeration value</param>
            <returns>Tag if enum member is marked, otherwise null</returns>
        </member>
        <member name="T:NetBox.Extensions.GuidExtensions">
            <summary>
            Guid extensions
            </summary>
        </member>
        <member name="M:NetBox.Extensions.GuidExtensions.ToShortest(System.Guid)">
            <summary>
            Returns shortest possible representation of guid as string i.e. 20 characters instead of
            36 comparing to built-int ToString() representation. It uses ASCII86 encoding to achieve this.
            See <see cref="M:NetBox.Extensions.StringExtensions.FromShortestGuid(System.String)"/> to convert back to Guid.
            </summary>
        </member>
        <member name="T:NetBox.Extensions.IntExtensions">
            <summary>
            <see cref="T:System.Int32"/> extension methods
            </summary>
        </member>
        <member name="M:NetBox.Extensions.IntExtensions.ToFileSizeString(System.Int32)">
            <summary>
            Converts number to readable size string in IEC format, i.e. 1024 converts to "1.02 KiB"
            </summary>
        </member>
        <member name="M:NetBox.Extensions.IntExtensions.ToFileSizeUiString(System.Int32)">
            <summary>
            Converts number to readable size string in SI format, i.e. 1024 converts to "1.02 KB"
            </summary>
        </member>
        <member name="M:NetBox.Extensions.IntExtensions.Seconds(System.Int32)">
            <summary>
            Converts number to seconds
            </summary>
            <param name="number">Number of seconds</param>
            <returns>Timespan values</returns>
        </member>
        <member name="M:NetBox.Extensions.IntExtensions.Minutes(System.Int32)">
            <summary>
            Converts number to minutes
            </summary>
            <param name="number">Number of minutes</param>
            <returns>Timespan value</returns>
        </member>
        <member name="M:NetBox.Extensions.IntExtensions.Hours(System.Int32)">
            <summary>
            Converts number to hours 
            </summary>
            <param name="number">Number of hours</param>
            <returns>Timespan value</returns>
        </member>
        <member name="T:NetBox.Extensions.ListExtensions">
            <summary>
            Extensions methods for <see cref="T:System.Collections.Generic.IList`1"/> and <see cref="T:System.Collections.IList"/>
            </summary>
        </member>
        <member name="M:NetBox.Extensions.ListExtensions.AddRange(System.Collections.IList,System.Collections.IEnumerable)">
            <summary>
            Adds range of elements into the non-generic list
            </summary>
            <param name="destination">The destination.</param>
            <param name="source">The source.</param>
        </member>
        <member name="M:NetBox.Extensions.ListExtensions.AddRange(System.Collections.IList,System.Collections.ICollection)">
            <summary>
            Adds range of elements into the non-generic list
            </summary>
            <param name="destination">The destination.</param>
            <param name="source">The source.</param>
        </member>
        <member name="T:NetBox.Extensions.LongExtensions">
            <summary>
            <see cref="T:System.Int64"/> extension methods
            </summary>
        </member>
        <member name="M:NetBox.Extensions.LongExtensions.ToFileSizeString(System.Int64)">
            <summary>
            Converts number to readable size string in IEC format, i.e. 1024 converts to "1.02 KiB"
            </summary>
        </member>
        <member name="M:NetBox.Extensions.LongExtensions.ToFileSizeUiString(System.Int64)">
            <summary>
            Converts number to readable size string in SI format, i.e. 1024 converts to "1.02 KB"
            </summary>
        </member>
        <member name="T:NetBox.Extensions.NetFile">
            <summary>
            <see cref="T:System.IO.File"/> extensions. Due to the fact <see cref="T:System.IO.File"/> is a static class and cannot be extended
            with extension methods this is implemented a new static class.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.NetFile.Gzip(System.String,System.String)">
            <summary>
            Gzips the file
            </summary>
            <param name="filePath">Path to the file to gzip</param>
            <param name="targetPath">Target file name for the gzipped file. Optional and when nul creates a new 
            file in the same folder appending the .gz extension. For example mytextfile.txt => mytextfile.txt.gz</param>
        </member>
        <member name="M:NetBox.Extensions.NetFile.Ungzip(System.String,System.String)">
            <summary>
            Ungzips the file
            </summary>
            <param name="filePath">Path to the file to ungzip</param>
            <param name="targetPath">Target file for the ungzipped file. Optional. When null source file must end with
            .gz extension and target file will be decompressed to a file without it. For example mytextfile.txt.gz => mytextfile.txt</param>
        </member>
        <member name="T:NetBox.Extensions.NetPath">
            <summary>
            <see cref="T:System.IO.Path"/> extensions. Due to the fact <see cref="T:System.IO.Path"/> is a static class and cannot be extended
            with extension methods this is implemented a new static class.
            </summary>
        </member>
        <member name="P:NetBox.Extensions.NetPath.ExecDir">
            <summary>
            Gets current assembly execution directory in a more reliable way
            </summary>
        </member>
        <member name="P:NetBox.Extensions.NetPath.ExecDirInfo">
            <summary>
            Gets current assembly execution directory information in a more reliable way
            </summary>
        </member>
        <member name="T:NetBox.Extensions.NetworkCredentialExtensions">
            <summary>
            Provides extension methods for <see cref="T:System.Net.NetworkCredential"/>
            </summary>
        </member>
        <member name="M:NetBox.Extensions.NetworkCredentialExtensions.ToFriendlyString(System.Net.NetworkCredential)">
            <summary>
            Converts to a friendly format which is username:password@domain
            </summary>
            <param name="credential">Credential to convert</param>
            <returns>Friendly string. If some parts are missing they are not added, for example if there is no
            domain information you'll get username:password.</returns>
        </member>
        <member name="T:NetBox.Extensions.ObjectExtensions">
            <summary>
            Object extensions.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.ObjectExtensions.XmlSerialise(System.Object)">
            <summary>
            Serialises any object to XML string if possible
            </summary>
            <param name="obj"></param>
            <returns>XML string</returns>
        </member>
        <member name="M:NetBox.Extensions.ObjectExtensions.JsonSerialise(System.Object)">
            <summary>
            Serialises an object using embedded JSON serialiser with zero dependencies.
            This is using source code from https://github.com/facebook-csharp-sdk/simple-json.
            </summary>
            <param name="obj">Object to serialise</param>
            <returns>JSON string</returns>
        </member>
        <member name="M:NetBox.Extensions.ObjectExtensions.AsEnumerable``1(``0)">
            <summary>
            Creates an enumerable from one element
            </summary>
            <typeparam name="T"></typeparam>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="T:NetBox.Extensions.StreamExtensions">
            <summary>
            <see cref="T:System.IO.Stream"/> extension
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StreamExtensions.TryGetSize(System.IO.Stream,System.Int64@)">
            <summary>
            Attemps to get the size of this stream by reading the Length property, otherwise returns 0.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StreamExtensions.TryGetSize(System.IO.Stream)">
            <summary>
            Attemps to get the size of this stream by reading the Length property, otherwise returns 0.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StreamExtensions.ReadUntil(System.IO.Stream,System.Byte[])">
            <summary>
            Reads the stream until a specified sequence of bytes is reached.
            </summary>
            <returns>Bytes before the stop sequence</returns>
        </member>
        <member name="M:NetBox.Extensions.StreamExtensions.ToByteArray(System.IO.Stream)">
            <summary>
            Reads all stream in memory and returns as byte array
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StreamExtensions.ToString(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Converts the stream to string using specified encoding. This is done by reading the stream into
            byte array first, then applying specified encoding on top.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StreamExtensions.GetHash(System.IO.Stream,NetBox.HashType)">
            <summary>
            Calculates hash on input stream.
            </summary>
            <param name="stream">Input stream.</param>
            <param name="hashType">Hash type to calculate.</param>
            <returns>Hexadecimal representation of byte array as string</returns>
        </member>
        <member name="M:NetBox.Extensions.StreamExtensions.GetHashBytes(System.IO.Stream,NetBox.HashType)">
            <summary>
            Calculates hash on input stream.
            </summary>
            <param name="stream">Input stream.</param>
            <param name="hashType">Hash type to calculate.</param>
            <returns>Hash</returns>
        </member>
        <member name="M:NetBox.Extensions.StreamExtensions.Gzip(System.IO.Stream,System.IO.Stream)">
            <summary>
            GZips source stream into a target stream
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StreamExtensions.Ungzip(System.IO.Stream,System.IO.Stream)">
            <summary>
            UnGZips source stream into a target stream
            </summary>
        </member>
        <member name="T:NetBox.Extensions.StringExtensions">
            <summary>
            String extensions.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.FromHexToBytes(System.String)">
            <summary>
            Convers hex string to byte array
            </summary>
            <param name="hex"></param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.StripHtml(System.String)">
            <summary>
            Strips HTML string from any tags leaving text only.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.HtmlEncode(System.String)">
            <summary>
            Encodes to HTML string
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.HtmlDecode(System.String)">
            <summary>
            Decodes from HTML string
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.UrlEncode(System.String)">
            <summary>
            URL-encodes input string
            </summary>
            <param name="value">String to encode</param>
            <returns>Encoded string</returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.UrlDecode(System.String)">
            <summary>
            URL-decodes input string
            </summary>
            <param name="value">String to decode</param>
            <returns>Decoded string</returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.XmlDeserialise``1(System.String)">
            <summary>
            Deserialises object represented as XML string to a real object.
            </summary>
            <typeparam name="T">Object type.</typeparam>
            <param name="s">XML representation.</param>
            <returns>Object instance.</returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.XmlDeserialise(System.String,System.Type)">
            <summary>
            Deserialises object represented as XML string to a real object.
            </summary>
            <param name="s">XML representation.</param>
            <param name="t">Object type.</param>
            <returns>Object instance.</returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.JsonDeserialise``1(System.String)">
            <summary>
            Deserialises an object using embedded JSON serialiser with zero dependencies.
            This is using source code from https://github.com/facebook-csharp-sdk/simple-json.
            </summary>
            <param name="s">String to deserialise</param>
            <typeparam name="T">Result object type</typeparam>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.JsonDeserialise(System.String,System.Type)">
            <summary>
            Deserialises an object using embedded JSON serialiser with zero dependencies.
            This is using source code from https://github.com/facebook-csharp-sdk/simple-json.
            </summary>
            <param name="s">String to deserialise</param>
            <param name="t">Result object type</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.JsonDeserialiseDictionary(System.String)">
            <summary>
            Deserialises an object using embedded JSON serialiser with zero dependencies.
            This is using source code from https://github.com/facebook-csharp-sdk/simple-json.
            </summary>
            <param name="s">String to deserialise</param>
            <returns>Key-value dictionary</returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.Base64Encode(System.String)">
            <summary>
            Encodes a string to BASE64 format
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.Base64Decode(System.String)">
            <summary>
            Decodes a BASE64 encoded string
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.Base64DecodeAsBytes(System.String)">
            <summary>
            Decodes a BASE64 encoded string to byte array
            </summary>
            <param name="s">String to decode</param>
            <returns>Byte array</returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.FromShortestGuid(System.String)">
            <summary>
            Converts shortest guid representation back to Guid. See <see cref="M:NetBox.Extensions.GuidExtensions.ToShortest(System.Guid)"/>
            on how to convert Guid to string.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.GetHash(System.String,NetBox.HashType)">
            <summary>
            Gets string hash
            </summary>
            <param name="s">Source string</param>
            <param name="hashType">Hash type</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.ToMemoryStream(System.String,System.Text.Encoding)">
            <summary>
            Converts to MemoryStream with a specific encoding
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.ToMemoryStream(System.String)">
            <summary>
            Converts to MemoryStream in UTF-8 encoding
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.SanitizePath(System.String)">
            <summary>
            Removes invalid path characters from the string, replacing them by space (' ') character
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.SanitizePath(System.String,System.Char)">
            <summary>
            Removes invalid path characters from the string, replacing them by the given character
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.MatchesWildcard(System.String,System.String)">
            <summary>
            Filesystem style widlcard match where * stands for any characters of any length and ? standa for one character
            </summary>
            <param name="s">input string</param>
            <param name="wildcard">wildcard</param>
            <returns>True if matches, false otherwise</returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.Gzip(System.String,System.Text.Encoding)">
            <summary>
            Gzips a specified string into array of bytes using specified encoding
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.Gzip(System.String,System.Text.Encoding,System.IO.Stream)">
            <summary>
            Gzips a specified string in specified encoding to to destination stream.
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.FindTagged(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Looks for <paramref name="startTag"/> and <paramref name="endTag"/> followed in sequence and when found returns the text between them.
            </summary>
            <param name="s">Input string</param>
            <param name="startTag">Start tag</param>
            <param name="endTag">End tag</param>
            <param name="includeOuterTags">When set to true, returns the complete phrase including start and end tag value,
            otherwise only inner text returned</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.ReplaceTagged(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Looks for <paramref name="startTag"/> and <paramref name="endTag"/> followed in sequence, and if found
            performs a replacement of text inside them with <paramref name="replacementText"/>
            </summary>
            <param name="s">Input string</param>
            <param name="startTag">Start tag</param>
            <param name="endTag">End tag</param>
            <param name="replacementText">Replacement text</param>
            <param name="replaceOuterTokens">When set to true, not only the text between tags is replaced, but the whole
            phrase with <paramref name="startTag"/>, text between tags and <paramref name="endTag"/></param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.SpacedToCamelCase(System.String)">
            <summary>
            Converts a string with spaces to a camel case version, for example
            "The camel string" is converted to "TheCamelString"
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.Capitalize(System.String)">
            <summary>
            Transforms the string so that the first letter is uppercase and the rest of them are lowercase
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.Slice(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>
            Pythonic approach to slicing strings
            </summary>
            <param name="s">Input string</param>
            <param name="start">Is the start index to slice from. It can be either positive or negative.
            Negative value indicates that the index is taken from the end of the string.</param>
            <param name="end">Is the index to slice to. It can be either positive or negative.
            Negative value indicates that the index is taken from the end of the string.</param>
            <returns>Sliced string</returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.SplitByDelimiter(System.String,System.String[])">
            <summary>
            Splits the string into key and value using the provided delimiter values. Both key and value are trimmed as well.
            </summary>
            <param name="s">Input string. When null returns null immediately.</param>
            <param name="delimiter">List of delmiters between key and value. This method searches for all the provided
            delimiters, and splits by the first left-most one.</param>
            <returns>A tuple of two values where the first one is the key and second is the value. If none of the delimiters
            are found the second value of the tuple is null and the first value is the input string</returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.ToNetworkCredential(System.String)">
            <summary>
            Converts string to network credentials if it's formatted in a friendly way.
            See <see cref="M:NetBox.Extensions.NetworkCredentialExtensions.ToFriendlyString(System.Net.NetworkCredential)"/> how to do it.
            </summary>
            <param name="s">String to conver from.</param>
            <returns>An instance of <see cref="T:System.Net.NetworkCredential"/></returns>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.PairedWith``1(System.String,``0)">
            <summary>
            Creates a key-value pair from this string and an object value
            </summary>
        </member>
        <member name="M:NetBox.Extensions.StringExtensions.WithObj(System.String,System.Object)">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> with <see cref="T:System.Object"/> value type
            </summary>
        </member>
        <member name="T:NetBox.Extensions.TaskExtensions">
            <summary>
            Task utility methods
            </summary>
        </member>
        <member name="M:NetBox.Extensions.TaskExtensions.Forget(System.Threading.Tasks.Task)">
            <summary>
            Fire-and-forget without compiler warnings
            </summary>
            <param name="task"></param>
        </member>
        <member name="T:NetBox.Extensions.TypeExtensions">
            <summary>
            <see cref="T:System.Type"/> extensions
            </summary>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.IsEnum(System.Type)">
            <summary>
            More reliable way to determine if a type is Enum
            </summary>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.IsSimple(System.Type)">
            <summary>
            Deterimites if type is "simple". It's hard to describe what a simple type is, but this is used mostly in serialization and
            says whether a type has to be expanded (not simple) or represented as a value.
            </summary>
            <param name="t">The type</param>
            <returns>True if a type is siimple</returns>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.IsNumber(System.Type)">
            <summary>
            Checks if this type is a primitive number, i.e. one of:
            - byte/sbyte
            - decimal
            - double
            - float
            - int
            - long/ulong
            - short/ushort
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.CreateDefaultValue(System.Type)">
            <summary>
            Creates the default value for type. It's null for reference type and 0 for int, float etc.
            </summary>
            <param name="t">The value.</param>
            <returns>Value</returns>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.GetHierarchyPublicProperties(System.Type)">
            <summary>
            Gets public properties of this type and all derived types.
            Handles both classes and interfaces.
            </summary>
            <param name="type">The type to operate on. Can be either a class or an interface.</param>
            <returns>Array of public properties</returns>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.GetAssembly(System.Type)">
            <summary>
            Gets the assembly this type is in
            </summary>
            <param name="t">The type.</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.ProductVersion(System.Type)">
            <summary>
            Gets the product version (set by [assembly:Version] attribute)
            </summary>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.FileVersion(System.Type)">
            <summary>
            Gets the file version (set by [assembly:FileVersion] attribute)
            </summary>
            <param name="t">A type within the assembly</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.GetSameFolderEmbeddedResourceFile(System.Type,System.String)">
            <summary>
            Reads embedded resource file which lies next to a type specified in TTypeNextToFile 
            </summary>
            <param name="type">Type which resides in the same folder as the resource</param>
            <param name="fileName">name of the file, i.e. "myresource.txt"</param>
            <returns>File stream if it exists, otherwise null</returns>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.GetSameFolderEmbeddedResourceFileAsText(System.Type,System.String)">
            <summary>
            Reads embedded resource file as text
            </summary>
            <param name="type">Type which resides in the same folder as the resource</param>
            <param name="fileName">name of the file, i.e. "myresource.txt"</param>
            <returns>File stream if it exists, otherwise null</returns>
        </member>
        <member name="M:NetBox.Extensions.TypeExtensions.GetSameFolderEmbeddedResourceFileAsLines``1(System.Type,System.String)">
            <summary>
            Reads embedded resource file as array of lines
            </summary>
            <typeparam name="TTypeNextToFile">This type must reside in the same folder as resource file</typeparam>
            <param name="type">Type which resides in the same folder as the resource</param>
            <param name="fileName">name of the file, i.e. "myresource.txt"</param>
            <returns>File stream if it exists, otherwise null</returns>
        </member>
        <member name="M:NetBox.FileFormats.CsvFormat.EscapeValue(System.String)">
            <summary>
            Implemented according to RFC4180 http://tools.ietf.org/html/rfc4180
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NetBox.FileFormats.CsvReader">
            <summary>
            Reads data from a CSV file. Fast and reliable, supports:
            - newline characters
            - double quotes
            - commas
            </summary>
        </member>
        <member name="M:NetBox.FileFormats.CsvReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Creates an instance from an open stream and encoding
            </summary>
        </member>
        <member name="M:NetBox.FileFormats.CsvReader.ReadAllFromContent(System.String,System.Boolean)">
            <summary>
            Reads all file as a dictionary of column name to list of values
            </summary>
            <param name="content">File content</param>
            <param name="hasColumns">When true, the first line of the file includes columns</param>
            <returns>Dictionary mapping the column name to the list of values</returns>
        </member>
        <member name="M:NetBox.FileFormats.CsvReader.ReadNextRow">
            <summary>
            Reads next row of data if available.
            </summary>
            <returns>Null when end of file is reached, or array of strings for each column.</returns>
        </member>
        <member name="T:NetBox.FileFormats.CsvWriter">
            <summary>
            Writes data to a CSV file. Fast and reliable, supports:
            - newline characters
            - double quotes
            - commas
            </summary>
        </member>
        <member name="M:NetBox.FileFormats.CsvWriter.#ctor(System.IO.Stream)">
            <summary>
            Creates a new instance of CsvWriter which uses UTF8 encoding
            </summary>
            <param name="destination"></param>
        </member>
        <member name="M:NetBox.FileFormats.CsvWriter.#ctor(System.String)">
            <summary>
            Creates a new instance of CsvWriter on disk with UTF8 encoding
            </summary>
            <param name="fileName">File name or path</param>
        </member>
        <member name="M:NetBox.FileFormats.CsvWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Creates a new instance of CsvWriter and allows to specify the writer encoding
            </summary>
            <param name="destination"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NetBox.FileFormats.CsvWriter.Write(System.String[])">
            <summary>
            Writes a row of data
            </summary>
        </member>
        <member name="M:NetBox.FileFormats.CsvWriter.Write(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Writes a row of data
            </summary>
        </member>
        <member name="T:NetBox.G">
            <summary>
            Global defaults
            </summary>
        </member>
        <member name="F:NetBox.G.Enc">
            <summary>
            Global default encoding
            </summary>
        </member>
        <member name="F:NetBox.G.C">
            <summary>
            Global default culture
            </summary>
        </member>
        <member name="T:NetBox.Generator.PasswordGenerator">
            <summary>
            Generates random passwords
            </summary>
        </member>
        <member name="M:NetBox.Generator.PasswordGenerator.Generate">
            <summary>
            Generates a random password using default password policy
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.Generator.PasswordGenerator.Generate(NetBox.Generator.PasswordPolicy)">
            <summary>
            Generates a random password.
            </summary>
            <param name="policy">
            Password generation policy
            </param>
            <returns>
            Randomly generated password.
            </returns>
            <remarks>
            The length of the generated password will be determined at
            random and it will fall with the range determined by the
            function parameters.
            </remarks>
        </member>
        <member name="T:NetBox.Generator.PasswordPolicy">
            <summary>
            Password policy used by <see cref="T:NetBox.Generator.PasswordGenerator"/>
            </summary>
        </member>
        <member name="M:NetBox.Generator.PasswordPolicy.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an intance
            </summary>
            <param name="minLength"></param>
            <param name="maxLength"></param>
        </member>
        <member name="P:NetBox.Generator.PasswordPolicy.MinLength">
            <summary>
            Minimum length of the password
            </summary>
        </member>
        <member name="P:NetBox.Generator.PasswordPolicy.MaxLength">
            <summary>
            Maximum length of the password
            </summary>
        </member>
        <member name="P:NetBox.Generator.PasswordPolicy.LowercaseCharacters">
            <summary>
            List of allowed lowercase characters
            </summary>
        </member>
        <member name="P:NetBox.Generator.PasswordPolicy.UppercaseCharacters">
            <summary>
            List of allowed uppercase characters
            </summary>
        </member>
        <member name="P:NetBox.Generator.PasswordPolicy.NumericCharacters">
            <summary>
            List of allowed numeric characters
            </summary>
        </member>
        <member name="P:NetBox.Generator.PasswordPolicy.SpecialCharacters">
            <summary>
            List of allowed special characters
            </summary>
        </member>
        <member name="T:NetBox.Generator.RandomGenerator">
            <summary>
            Generates random data using <see cref="T:System.Security.Cryptography.RandomNumberGenerator"/> for increased security
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomBool">
            <summary>
            Generates a random boolean
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomLong">
            <summary>
            Generates a random long number between 0 and max
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomInt">
            <summary>
            Generates a random integer between 0 and max
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomDouble">
            <summary>
            Returns random double
            </summary>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomInt(System.Int32)">
            <summary>
            Generates a random integer until max parameter
            </summary>
            <param name="max">Maximum integer value, excluding</param>
            <returns></returns>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomInt(System.Int32,System.Int32)">
            <summary>
            Generates a random integer number in range
            </summary>
            <param name="min">Minimum value, including</param>
            <param name="max">Maximum value, excluding</param>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomLong(System.Int64,System.Int64)">
            <summary>
            Generates a random long number in range
            </summary>
            <param name="min">Minimum value, including</param>
            <param name="max">Maximum value, excluding</param>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.RandomEnum(System.Type)">
            <summary>
            Generates a random enum value by type
            </summary>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomEnum``1">
            <summary>
            Generates a random enum value
            </summary>
            <typeparam name="T">Enumeration type</typeparam>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomDate(System.DateTime,System.DateTime)">
            <summary>
            Generates a random date in range
            </summary>
            <param name="minValue">Minimum date, including</param>
            <param name="maxValue">Maximum date, excluding</param>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomDate">
            <summary>
            Generates a random date value
            </summary>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomString">
            <summary>
            Generates a random string. Never returns null.
            </summary>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomString(System.Int32,System.Boolean)">
            <summary>
            Generates a random string
            </summary>
            <param name="length">string length</param>
            <param name="allowNulls">Whether to allow to return null values</param>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomUri(System.Boolean)">
            <summary>
            Generates a random URL in format "http://random.com/random.random
            </summary>
            <param name="allowNulls">Whether to allow to return nulls</param>
        </member>
        <member name="P:NetBox.Generator.RandomGenerator.RandomUri">
            <summary>
            Generates a random URL in format "http://random.com/random.random. Never returns null values.
            </summary>
        </member>
        <member name="M:NetBox.Generator.RandomGenerator.GetRandomBytes(System.Int32,System.Int32)">
            <summary>
            Generates a random sequence of bytes of a specified size
            </summary>
        </member>
        <member name="T:NetBox.IO.BoundedStream">
            <summary>
            Works on top of a subportion of a stream, making only a small window visible
            </summary>
        </member>
        <member name="T:NetBox.IO.DelegatedStream">
            <summary>
            Makes stream members virtual instead of abstract, allowing to override only specific behaviors.
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.#ctor(System.IO.Stream)">
            <summary>
            Creates an instance of non-closeable stream
            </summary>
            <param name="master"></param>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.CanRead">
            <summary>
            Calls <see cref="M:NetBox.IO.DelegatedStream.GetCanRead"/>
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.GetCanRead">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.CanSeek">
            <summary>
            Calls <see cref="M:NetBox.IO.DelegatedStream.GetCanSeek"/>
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.GetCanSeek">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.CanWrite">
            <summary>
            Calls <see cref="M:NetBox.IO.DelegatedStream.GetCanWrite"/>
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.GetCanWrite">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.Length">
            <summary>
            Calls <see cref="M:NetBox.IO.DelegatedStream.GetLength"/>
            </summary>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.GetLength">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetBox.IO.DelegatedStream.Position">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.Flush">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.SetLength(System.Int64)">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetBox.IO.DelegatedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Delegates to master by default
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetBox.IO.NonCloseableStream">
            <summary>
            Represents a stream that ignores <see cref="T:System.IDisposable"/> operations i.e. cannot be closed by the client
            </summary>
        </member>
        <member name="M:NetBox.IO.NonCloseableStream.#ctor(System.IO.Stream)">
            <summary>
            Creates an instance of this class
            </summary>
            <param name="master">Master stream to delegate operations to</param>
        </member>
        <member name="M:NetBox.IO.NonCloseableStream.Dispose(System.Boolean)">
            <summary>
            Overrides this call to do nothing
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NetBox.Json">
            <summary>
            Common JavaScript helpers
            </summary>
        </member>
        <member name="M:NetBox.Json.ToEscapedString(System.String)">
            <summary>
            Escapes a string for JSON encoding
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:NetBox.Model.EnumTagAttribute">
            <summary>
            Tags enums for assigning extra data such as alternative ID, Description etc.
            </summary>
        </member>
        <member name="P:NetBox.Model.EnumTagAttribute.Id">
            <summary>
            Alternative string version of ID
            </summary>
        </member>
        <member name="P:NetBox.Model.EnumTagAttribute.DisplayName">
            <summary>
            Display name
            </summary>
        </member>
        <member name="M:NetBox.Model.EnumTagAttribute.#ctor">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:NetBox.Model.EnumTagAttribute.#ctor(System.String,System.String)">
            <summary>
            Creates an instance
            </summary>
            <param name="id">Alternative string version of ID</param>
            <param name="displayName">Display name</param>
        </member>
        <member name="M:NetBox.Model.EnumTagAttribute.GetById``1(System.String)">
            <summary>
            Finds enum member by tagged ID
            </summary>
            <typeparam name="T">Enumeration type</typeparam>
            <param name="id">Tagged id</param>
            <returns>Enumeration member if gived ID is found, otherwise null</returns>
        </member>
        <member name="T:NetBox.Model.FileSearchOptions">
            <summary>
            Options saying how to limit the file search
            </summary>
        </member>
        <member name="M:NetBox.Model.FileSearchOptions.#ctor(System.String)">
            <summary>
            Craetes a new instance of <see cref="T:NetBox.Model.FileSearchOptions"/>
            </summary>
            <param name="includePattern"></param>
        </member>
        <member name="P:NetBox.Model.FileSearchOptions.IncludePatterns">
            <summary>
            Include patterns
            </summary>
        </member>
        <member name="T:NetBox.HashType">
            <summary>
            Supported hashing algorithms
            </summary>
        </member>
        <member name="F:NetBox.HashType.Md5">
            <summary>
            500Mb hashes in 1462 ms, size: 16b
            </summary>
        </member>
        <member name="F:NetBox.HashType.Sha1">
            <summary>
            500Mb hashes in 1644 ms, size: 20b
            </summary>
        </member>
        <member name="F:NetBox.HashType.Sha256">
            <summary>
            500Mb hashes in 5618 ms, size: 32b
            </summary>
        </member>
        <member name="F:NetBox.HashType.Sha384">
            <summary>
            500Mb hashes in 3839 ms, size: 48b
            </summary>
        </member>
        <member name="F:NetBox.HashType.Sha512">
            <summary>
            500Mb hashes in 3820 ms, size: 64b
            </summary>
        </member>
        <member name="F:NetBox.HashType.RipeMd160">
            <summary>
            500Mb hashes in 7066 ms, size: 20b
            </summary>
        </member>
        <member name="T:NetBox.Performance.Measure">
            <summary>
            Measures a time slice as precisely as possible
            </summary>
        </member>
        <member name="M:NetBox.Performance.Measure.#ctor">
            <summary>
            Creates the measure object
            </summary>
        </member>
        <member name="P:NetBox.Performance.Measure.ElapsedTicks">
            <summary>
            Returns number of elapsed ticks since the start of measure.
            The measuring process will continue running.
            </summary>
        </member>
        <member name="P:NetBox.Performance.Measure.ElapsedMilliseconds">
            <summary>
            Returns number of elapsed milliseconds since the start of measure.
            The measuring process will continue running.
            </summary>
        </member>
        <member name="M:NetBox.Performance.Measure.Dispose">
            <summary>
            Stops measure object if still running
            </summary>
        </member>
        <member name="T:SimpleJson.JsonArray">
            <summary>
            Represents the json array.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonArray.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleJson.JsonArray"/> class. 
            </summary>
        </member>
        <member name="M:SimpleJson.JsonArray.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:SimpleJson.JsonArray"/> class. 
            </summary>
            <param name="capacity">The capacity of the json array.</param>
        </member>
        <member name="M:SimpleJson.JsonArray.ToString">
            <summary>
            The json representation of the array.
            </summary>
            <returns>The json representation of the array.</returns>
        </member>
        <member name="T:SimpleJson.JsonObject">
            <summary>
            Represents the json object.
            </summary>
        </member>
        <member name="F:SimpleJson.JsonObject._members">
            <summary>
            The internal member dictionary.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonObject.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:SimpleJson.JsonObject"/>.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonObject.#ctor(System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Initializes a new instance of <see cref="T:SimpleJson.JsonObject"/>.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use when comparing keys, or null to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/> for the type of the key.</param>
        </member>
        <member name="P:SimpleJson.JsonObject.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:System.Object"/> at the specified index.
            </summary>
            <value></value>
        </member>
        <member name="M:SimpleJson.JsonObject.Add(System.String,System.Object)">
            <summary>
            Adds the specified key.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:SimpleJson.JsonObject.ContainsKey(System.String)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
                <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="P:SimpleJson.JsonObject.Keys">
            <summary>
            Gets the keys.
            </summary>
            <value>The keys.</value>
        </member>
        <member name="M:SimpleJson.JsonObject.Remove(System.String)">
            <summary>
            Removes the specified key.
            </summary>
            <param name="key">The key.</param>
            <returns></returns>
        </member>
        <member name="M:SimpleJson.JsonObject.TryGetValue(System.String,System.Object@)">
            <summary>
            Tries the get value.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="P:SimpleJson.JsonObject.Values">
            <summary>
            Gets the values.
            </summary>
            <value>The values.</value>
        </member>
        <member name="P:SimpleJson.JsonObject.Item(System.String)">
            <summary>
            Gets or sets the <see cref="T:System.Object"/> with the specified key.
            </summary>
            <value></value>
        </member>
        <member name="M:SimpleJson.JsonObject.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Adds the specified item.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:SimpleJson.JsonObject.Clear">
            <summary>
            Clears this instance.
            </summary>
        </member>
        <member name="M:SimpleJson.JsonObject.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Determines whether [contains] [the specified item].
            </summary>
            <param name="item">The item.</param>
            <returns>
            	<c>true</c> if [contains] [the specified item]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:SimpleJson.JsonObject.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
            <summary>
            Copies to.
            </summary>
            <param name="array">The array.</param>
            <param name="arrayIndex">Index of the array.</param>
        </member>
        <member name="P:SimpleJson.JsonObject.Count">
            <summary>
            Gets the count.
            </summary>
            <value>The count.</value>
        </member>
        <member name="P:SimpleJson.JsonObject.IsReadOnly">
            <summary>
            Gets a value indicating whether this instance is read only.
            </summary>
            <value>
            	<c>true</c> if this instance is read only; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:SimpleJson.JsonObject.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            Removes the specified item.
            </summary>
            <param name="item">The item.</param>
            <returns></returns>
        </member>
        <member name="M:SimpleJson.JsonObject.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SimpleJson.JsonObject.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:SimpleJson.JsonObject.ToString">
            <summary>
            Returns a json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A json <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="T:SimpleJson.SimpleJson">
            <summary>
            This class encodes and decodes JSON strings.
            Spec. details, see http://www.json.org/
            
            JSON uses Arrays and Objects. These correspond here to the datatypes JsonArray(IList&lt;object>) and JsonObject(IDictionary&lt;string,object>).
            All numbers are parsed to doubles.
            </summary>
        </member>
        <member name="M:SimpleJson.SimpleJson.DeserializeObject(System.String)">
            <summary>
            Parses the string json into a value
            </summary>
            <param name="json">A JSON string.</param>
            <returns>An IList&lt;object>, a IDictionary&lt;string,object>, a double, a string, null, true, or false</returns>
        </member>
        <member name="M:SimpleJson.SimpleJson.TryDeserializeObject(System.String,System.Object@)">
            <summary>
            Try parsing the json string into a value.
            </summary>
            <param name="json">
            A JSON string.
            </param>
            <param name="obj">
            The object.
            </param>
            <returns>
            Returns true if successfull otherwise false.
            </returns>
        </member>
        <member name="M:SimpleJson.SimpleJson.SerializeObject(System.Object,SimpleJson.IJsonSerializerStrategy)">
            <summary>
            Converts a IDictionary&lt;string,object> / IList&lt;object> object into a JSON string
            </summary>
            <param name="json">A IDictionary&lt;string,object> / IList&lt;object></param>
            <param name="jsonSerializerStrategy">Serializer strategy to use</param>
            <returns>A JSON encoded string, or null if object 'json' is not serializable</returns>
        </member>
        <member name="M:SimpleJson.SimpleJson.IsNumeric(System.Object)">
            <summary>
            Determines if a given object is numeric in any way
            (can be integer, double, null, etc).
            </summary>
        </member>
    </members>
</doc>

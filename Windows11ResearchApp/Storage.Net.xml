<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Storage.Net</name>
    </assembly>
    <members>
        <member name="T:Storage.Net.Blobs.Blob">
            <summary>
            Blob item description
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.Kind">
            <summary>
            Gets the kind of item
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.IsFolder">
            <summary>
            Simply checks if kind of this item is <see cref="F:Storage.Net.Blobs.BlobItemKind.Folder"/>
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.IsFile">
            <summary>
            Simply checks if kind of this item is <see cref="F:Storage.Net.Blobs.BlobItemKind.File"/>
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.FolderPath">
            <summary>
            Gets the folder path containing this item
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.Name">
            <summary>
            Gets the name of this blob, uniqueue within the folder. In most providers this is the same as file name.
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.Size">
            <summary>
            Blob size
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.MD5">
            <summary>
            MD5 content hash of the blob. Note that this property can be null if underlying storage has
            no information about the hash, or it's very expensive to calculate it, for instance it would require
            getting a whole content of the blob to hash it.
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.CreatedTime">
            <summary>
            Creation time when known
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.LastModificationTime">
            <summary>
            Last modification time when known
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.FullPath">
            <summary>
            Gets full path to this blob which is a combination of folder path and blob name
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.Properties">
            <summary>
            Custom provider-specific properties. Key names are case-insensitive.
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.TryGetProperty``1(System.String,``0@,``0)">
            <summary>
            Try to get property and cast it to a specified type
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.Metadata">
            <summary>
            User defined metadata. Key names are case-insensitive.
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.TryAddProperties(System.Object[])">
            <summary>
            Tries to add properties in pairs when value is not null
            </summary>
            <param name="keyValues"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.TryAddPropertiesWithPrefix(System.String,System.Object[])">
            <summary>
            Works just like <see cref="M:Storage.Net.Blobs.Blob.TryAddProperties(System.Object[])"/> but prefixes all the keys
            </summary>
            <param name="prefix"></param>
            <param name="keyValues"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.TryAddPropertiesFromDictionary(System.Collections.Generic.IDictionary{System.String,System.String},System.String[])">
            <summary>
            Tries to add properties from dictionary by key names
            </summary>
            <param name="source"></param>
            <param name="keyNames"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.#ctor(System.String,Storage.Net.Blobs.BlobItemKind)">
            <summary>
            Create a new instance
            </summary>
            <param name="fullPath"></param>
            <param name="kind"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.#ctor(System.String,System.String,Storage.Net.Blobs.BlobItemKind)">
            <summary>
            Creates a new instance
            </summary>
            <param name="folderPath">Folder path to the blob</param>
            <param name="name">Name of the blob withing a specific folder.</param>
            <param name="kind">Blob kind (file or folder)</param>
        </member>
        <member name="P:Storage.Net.Blobs.Blob.IsRootFolder">
            <summary>
            Returns true if this item is a folder and it's a root folder
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.ToString">
            <summary>
            Full blob info, i.e type, id and path
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.Equals(Storage.Net.Blobs.Blob)">
            <summary>
            Equality check
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.Equals(System.Object)">
            <summary>
            Equality check
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.GetHashCode">
            <summary>
            Hash code calculation
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.op_Implicit(System.String)~Storage.Net.Blobs.Blob">
            <summary>
            Constructs a file blob by full ID
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.op_Implicit(Storage.Net.Blobs.Blob)~System.String">
            <summary>
            Converts blob to string by using full path
            </summary>
            <param name="blob"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.AttributesToByteArray">
            <summary>
            Converts blob attributes (user metadata to byte array)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.AppendAttributesFromByteArray(System.Byte[])">
            <summary>
            Appends attributes from byte array representation
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.PrependPath(System.String)">
            <summary>
            Prepends path to this blob's path without modifying blob's properties
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.SetFullPath(System.String)">
            <summary>
            Changes full path of this blob without modifying any other property
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Blob.Clone">
            <summary>
            Clones blob to best efforts
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Blobs.BlobItemKind">
            <summary>
            Type of the blob item in the storage
            </summary>
        </member>
        <member name="F:Storage.Net.Blobs.BlobItemKind.File">
            <summary>
            The file
            </summary>
        </member>
        <member name="F:Storage.Net.Blobs.BlobItemKind.Folder">
            <summary>
            The folder
            </summary>
        </member>
        <member name="T:Storage.Net.Blobs.BlobStorageExtensions">
            <summary>
            Blob storage on steroids. Takes in <see cref="T:Storage.Net.Blobs.IBlobStorage"/> and adds a lot of extra useful operations on top we as
            normal people use every day.
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.ListFilesAsync(Storage.Net.Blobs.IBlobStorage,Storage.Net.Blobs.ListOptions,System.Threading.CancellationToken)">
            <summary>
            Returns the list of available files, excluding folders.
            </summary>
            <param name="blobStorage"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns>List of blob IDs</returns>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.ListAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.Func{Storage.Net.Blobs.Blob,System.Boolean},System.String,System.Boolean,System.Nullable{System.Int32},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns the list of available blobs
            </summary>
            <param name="blobStorage"></param>
            <param name="folderPath"><see cref="P:Storage.Net.Blobs.ListOptions.FolderPath"/></param>
            <param name="browseFilter"><see cref="P:Storage.Net.Blobs.ListOptions.BrowseFilter"/></param>
            <param name="filePrefix"><see cref="P:Storage.Net.Blobs.ListOptions.FilePrefix"/></param>
            <param name="recurse"><see cref="P:Storage.Net.Blobs.ListOptions.Recurse"/></param>
            <param name="maxResults"><see cref="P:Storage.Net.Blobs.ListOptions.MaxResults"/></param>
            <param name="includeAttributes"><see cref="P:Storage.Net.Blobs.ListOptions.IncludeAttributes"/></param>
            <param name="cancellationToken"></param>
            <returns>List of blob IDs</returns>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.ReadTextAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Reads blob content and converts to text in UTF-8 encoding
            </summary>
            <param name="provider"></param>
            <param name="fullPath">Blob id</param>
            <param name="textEncoding">Optional text encoding. When not specified, <see cref="T:System.Text.UTF8Encoding"/> is used.</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.WriteTextAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Converts text to blob content and writes to storage
            </summary>
            <param name="provider"></param>
            <param name="fullPath">Blob to write</param>
            <param name="text">Text to write, treated in UTF-8 encoding</param>
            <param name="textEncoding">Optional text encoding. When not specified, <see cref="T:System.Text.UTF8Encoding"/> is used.</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.ExistsAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Checksi if blobs exists in the storage
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.DeleteAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Deletes a single blob or a folder recursively.
            </summary>
            <param name="storage"></param>
            <param name="fullPath"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.DeleteAsync(Storage.Net.Blobs.IBlobStorage,System.Collections.Generic.IEnumerable{Storage.Net.Blobs.Blob},System.Threading.CancellationToken)">
            <summary>
            Deletes a collection of blobs or folders
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.GetBlobAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Gets basic blob metadata
            </summary>
            <returns>Blob metadata or null if blob doesn't exist</returns>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.SetBlobAsync(Storage.Net.Blobs.IBlobStorage,Storage.Net.Blobs.Blob,System.Threading.CancellationToken)">
            <summary>
            Set blob attributes
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.WriteAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.Byte[],System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Writes byte array to the target storage. If you can, never use large byte arrays, they are terrible!
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.ReadBytesAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Reads blob content as byte array
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.ReadToStreamAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Downloads blob to a stream
            </summary>
            <param name="provider"></param>
            <param name="fullPath">Blob ID, required</param>
            <param name="targetStream">Target stream to copy to, required</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when any parameter is null</exception>
            <exception cref="T:System.ArgumentException">Thrown when ID is too long. Long IDs are the ones longer than 50 characters.</exception>
            <exception cref="T:Storage.Net.StorageException">Thrown when blob does not exist, error code set to <see cref="F:Storage.Net.ErrorCode.NotFound"/></exception>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.ReadToFileAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Downloads a blob to the local filesystem.
            </summary>
            <param name="provider"></param>
            <param name="fullPath">Blob ID to download</param>
            <param name="filePath">Full path to the local file to be downloaded to. If the file exists it will be recreated wtih blob data.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.WriteFileAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Uploads local file to the blob storage
            </summary>
            <param name="provider"></param>
            <param name="fullPath">Blob ID to create or overwrite</param>
            <param name="filePath">Path to local file</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.WriteJsonAsync``1(Storage.Net.Blobs.IBlobStorage,System.String,``0,System.Text.Json.JsonSerializerOptions,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Writes an object to blob storage using <see cref="T:System.Text.Json.JsonSerializer"/>
            </summary>
            <typeparam name="T">Objec type</typeparam>
            <param name="storage"></param>
            <param name="fullPath">Full path to blob</param>
            <param name="instance">Object instance to write</param>
            <param name="options">Optional serialiser options</param>
            <param name="encoding">Text encoding used to write to the blob storage, defaults to <see cref="T:System.Text.UTF8Encoding"/></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.ReadJsonAsync``1(Storage.Net.Blobs.IBlobStorage,System.String,System.Boolean,System.Text.Json.JsonSerializerOptions,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Reads an object from blob storage using <see cref="T:System.Text.Json.JsonSerializer"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="storage"></param>
            <param name="fullPath">Full path to blob</param>
            <param name="ignoreInvalidJson">When true, json that cannot be deserialised is ignored and method simply returns default value</param>
            <param name="options">Optional serialiser options</param>
            <param name="encoding">Text encoding used to write to the blob storage, defaults to <see cref="T:System.Text.UTF8Encoding"/></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.CopyToAsync(Storage.Net.Blobs.IBlobStorage,System.String,Storage.Net.Blobs.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Copies blob to another storage
            </summary>
            <param name="provider"></param>
            <param name="blobId">Blob ID to copy</param>
            <param name="targetStorage">Target storage</param>
            <param name="newId">Optional, when specified uses this id in the target storage. If null uses the original ID.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.GetMD5HashAsync(Storage.Net.Blobs.IBlobStorage,Storage.Net.Blobs.Blob,System.Threading.CancellationToken)">
            <summary>
            Calculates an MD5 hash of a blob. Comparing to <see cref="P:Storage.Net.Blobs.Blob.MD5"/> field, it always returns
            a hash, even if the underlying storage doesn't support it natively.
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.RenameAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Rename a blob (folder, file etc.).
            </summary>
            <param name="blobStorage"></param>
            <param name="oldPath"></param>
            <param name="newPath"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blobs.BlobStorageExtensions.CreateFolderAsync(Storage.Net.Blobs.IBlobStorage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Creates a new folder in this storage. If storage supports hierarchy, the folder is created as is, otherwise a folder is created by putting a dummy zero size file in that folder.
            </summary>
            <param name="blobStorage"></param>
            <param name="folderPath">Path to the folder</param>
            <param name="dummyFileName">If storage doesn't support hierary, you can override the dummy file name created in that empty folder.</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Blobs.Files.DiskDirectoryBlobStorage">
            <summary>
            Blob storage implementation which uses local file system directory
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Files.DiskDirectoryBlobStorage.#ctor(System.String)">
            <summary>
            Creates an instance in a specific disk directory
            <param name="directoryFullName">Root directory</param>
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Files.DiskDirectoryBlobStorage.ListAsync(Storage.Net.Blobs.ListOptions,System.Threading.CancellationToken)">
            <summary>
            Returns the list of blob names in this storage, optionally filtered by prefix
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Files.DiskDirectoryBlobStorage.Dispose">
            <summary>
            dispose
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Files.DiskDirectoryBlobStorage.OpenReadAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Opens file and returns the open stream
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Files.DiskDirectoryBlobStorage.DeleteAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Deletes files if they exist
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Files.DiskDirectoryBlobStorage.ExistsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Checks if files exist on disk
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Files.DiskDirectoryBlobStorage.GetBlobsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Files.DiskDirectoryBlobStorage.OpenTransactionAsync">
            <summary>
            Returns empty transaction as filesystem has no transaction support
            </summary>
        </member>
        <member name="T:Storage.Net.Blobs.GenericBlobStorage">
            <summary>
            Provides the most generic form of the blob storage implementation
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.GenericBlobStorage.CanListHierarchy">
            <summary>
            Return true if storage can list hierarchy in one call
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.ListAsync(Storage.Net.Blobs.ListOptions,System.Threading.CancellationToken)">
            <summary>
            Lists blobs
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.ListAtAsync(System.String,Storage.Net.Blobs.ListOptions,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.DeleteAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Delete all blobs
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.DeleteSingleAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Deletes one
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.ExistsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.ExistsAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.GetBlobsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.GetBlobAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.OpenReadAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.OpenTransactionAsync">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.WriteAsync(System.String,System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.SetBlobsAsync(System.Collections.Generic.IEnumerable{Storage.Net.Blobs.Blob},System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.GenericBlobStorage.Dispose">
            <summary>
            Dispose any unused resources
            </summary>
        </member>
        <member name="T:Storage.Net.Blobs.IBlobStorage">
            <summary>
            Slim interface providing access to blob storage.
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.IBlobStorage.ListAsync(Storage.Net.Blobs.ListOptions,System.Threading.CancellationToken)">
            <summary>
            Returns the list of available blobs
            </summary>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns>List of blob IDs</returns>
        </member>
        <member name="M:Storage.Net.Blobs.IBlobStorage.WriteAsync(System.String,System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Uploads data to a blob from stream.
            overwritten.
            </summary>
            <param name="fullPath">Blob metadata</param>
            <param name="dataStream">Stream to upload from</param>
            <param name="cancellationToken"></param>
            <param name="append">When true, appends to the file instead of writing a new one.</param>
            <returns>Writeable stream</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when any parameter is null</exception>
            <exception cref="T:System.ArgumentException">Thrown when ID is too long. Long IDs are the ones longer than 50 characters.</exception>
        </member>
        <member name="M:Storage.Net.Blobs.IBlobStorage.OpenReadAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Opens the blob stream to read.
            </summary>
            <param name="fullPath">Blob's full path</param>
            <param name="cancellationToken"></param>
            <returns>Stream in an open state, or null if blob doesn't exist by this ID. It is your responsibility to close and dispose this
            stream after use.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when any parameter is null</exception>
            <exception cref="T:System.ArgumentException">Thrown when ID is too long. Long IDs are the ones longer than 50 characters.</exception>
        </member>
        <member name="M:Storage.Net.Blobs.IBlobStorage.DeleteAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Deletes an object by it's full path.
            </summary>
            <param name="fullPaths">Path to delete. If this path points to a folder, the folder is deleted recursively.</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when ID is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when ID is too long. Long IDs are the ones longer than 50 characters.</exception>
        </member>
        <member name="M:Storage.Net.Blobs.IBlobStorage.ExistsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Checksi if blobs exists in the storage
            </summary>
            <param name="fullPaths">List of paths to blobs</param>
            <param name="cancellationToken"></param>
            <returns>List of results of true and false indicating existence</returns>
        </member>
        <member name="M:Storage.Net.Blobs.IBlobStorage.GetBlobsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Gets blob information which is useful for retreiving blob metadata
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.IBlobStorage.SetBlobsAsync(System.Collections.Generic.IEnumerable{Storage.Net.Blobs.Blob},System.Threading.CancellationToken)">
            <summary>
            Set blob information which is useful for setting blob attributes (user metadata etc.)
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.IBlobStorage.OpenTransactionAsync">
            <summary>
            Starts a new transaction
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Blobs.IExtendedBlobStorage">
            <summary>
            Extended blob storage operations that may be supported natively by a provider as are slow otherwise.
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.IExtendedBlobStorage.RenameAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Rename a blob (folder or file)
            </summary>
            <param name="oldPath"></param>
            <param name="newPath"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Blobs.IHierarchicalBlobStorage">
            <summary>
            Blob Storage that supports hierarchy
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.IHierarchicalBlobStorage.CreateFolderAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Creates a new folder
            </summary>
            <param name="folderPath">Path to the new folder.</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Blobs.ListOptions">
            <summary>
            Options for listing storage content
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.ListOptions.FolderPath">
            <summary>
            Folder path to start browsing from. When not set scanning starts from the root folder.
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.ListOptions.BrowseFilter">
            <summary>
            Gets or sets a browsing filter used by some implementations which can filter out results before returning it to you.
            This is useful to minimise amount of RAM taken when returning the results and then filtering them on client side.
            Note that filtering will be happening on the client side, therefore this is the least efficient filter and should
            only be used when you're concerned about RAM usage.
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.ListOptions.FilePrefix">
            <summary>
            Prefix to filter file name by. Folders are not affected by this filter. If you list files recursively
            the prefix is applied in every folder.
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.ListOptions.Recurse">
            <summary>
            When true, operation will recursively navigate down the folders.
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.ListOptions.MaxResults">
            <summary>
            When set, limits the maximum amount of results. The count affects all object counts, including files and folders.
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.ListOptions.IncludeAttributes">
            <summary>
            When set, includes blob attributes in the response if the provider supports it. False by default
            only because metadata consumes more memory in response object, although most of the providers do not
            have any overhead in creating this metadata.
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.ListOptions.IsMatch(Storage.Net.Blobs.Blob)">
            <summary>
            Helper method that returns true if a <see cref="T:Storage.Net.Blobs.Blob"/> matches these list options.
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.ListOptions.Add(System.Collections.Generic.ICollection{Storage.Net.Blobs.Blob},System.Collections.Generic.ICollection{Storage.Net.Blobs.Blob})">
            <summary>
            Only for internal use
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.ListOptions.Clone">
            <summary>
            Clones list options
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Blobs.Sinks.Impl.GZipSink">
            <summary>
            GZip transformation sink
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Sinks.Impl.GZipSink.#ctor(System.IO.Compression.CompressionLevel)">
            <summary>
            
            </summary>
            <param name="compressionLevel"></param>
        </member>
        <member name="M:Storage.Net.Blobs.Sinks.Impl.GZipSink.OpenReadStream(System.String,System.IO.Stream)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Sinks.Impl.GZipSink.OpenWriteStream(System.String,System.IO.Stream)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Storage.Net.Blobs.Sinks.Impl.SymmetricEncryptionSink">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Sinks.Impl.SymmetricEncryptionSink.#ctor(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Sinks.Impl.SymmetricEncryptionSink.OpenReadStream(System.String,System.IO.Stream)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Sinks.Impl.SymmetricEncryptionSink.OpenWriteStream(System.String,System.IO.Stream)">
            <summary>
            
            </summary>
        </member>
        <member name="T:Storage.Net.Blobs.Sinks.ITransformSink">
            <summary>
            Data transformation sink that can transform both read and write streams on <see cref="T:Storage.Net.Blobs.IBlobStorage"/>
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.Sinks.ITransformSink.OpenReadStream(System.String,System.IO.Stream)">
            <summary>
            Opens a stream for reading based on opened original stream
            </summary>
            <param name="fullPath">Full path to file</param>
            <param name="parentStream">Parent stream that is already open</param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blobs.Sinks.ITransformSink.OpenWriteStream(System.String,System.IO.Stream)">
            <summary>
            Opens a stream for writing based on opened original stream
            </summary>
            <param name="fullPath">Full path to file</param>
            <param name="parentStream">Source stream to write</param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Blobs.StorageSourceStream">
            <summary>
            Fixes common issues in streams that different implementations are really silly about
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.StorageSourceStream.#ctor(System.IO.Stream)">
            <summary>
            
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.StorageSourceStream.CanRead">
            <summary>
            No change
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.StorageSourceStream.CanSeek">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.StorageSourceStream.CanWrite">
            <summary>
            Always false
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.StorageSourceStream.Length">
            <summary>
            No change
            </summary>
        </member>
        <member name="P:Storage.Net.Blobs.StorageSourceStream.Position">
            <summary>
            No change
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.StorageSourceStream.Flush">
            <summary>
            No change
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.StorageSourceStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            see <see cref="M:Storage.Net.Blobs.StorageSourceStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.StorageSourceStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            No change, but remembers that read was performed
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.StorageSourceStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Only allows seeks to beginning if no reads were performed
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.StorageSourceStream.SetLength(System.Int64)">
            <summary>
            Change to "not supported"
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.StorageSourceStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Change to "not supported"
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.StorageSourceStream.Dispose(System.Boolean)">
            <summary>
            No change
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:Storage.Net.Blobs.VirtualStorage">
            <summary>
            Allows to combine several storage providers (or even of the same type) in one virtual storage interface.
            Providers are distinguished using a prefix. Essentially this allows to mount providers in a virtual filesystem.
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.#ctor">
            <summary>
            Creates an instance
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.Mount(System.String,Storage.Net.Blobs.IBlobStorage)">
            <summary>
            Mounts a storage to virtual path
            </summary>
            <param name="path"></param>
            <param name="storage"></param>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.Explode(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Simpler version of Explode that does not need to match to the result
            </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.DeleteAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
             <summary>
            
             </summary>
             <param name="fullPaths"></param>
             <param name="cancellationToken"></param>
             <returns></returns>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.Dispose">
             <summary>
            
             </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.ExistsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
             <summary>
            
             </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.GetBlobsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
             <summary>
            
             </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.ListAsync(Storage.Net.Blobs.ListOptions,System.Threading.CancellationToken)">
             <summary>
            
             </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.OpenReadAsync(System.String,System.Threading.CancellationToken)">
             <summary>
            
             </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.SetBlobsAsync(System.Collections.Generic.IEnumerable{Storage.Net.Blobs.Blob},System.Threading.CancellationToken)">
             <summary>
            
             </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.OpenTransactionAsync">
             <summary>
            
             </summary>
        </member>
        <member name="M:Storage.Net.Blobs.VirtualStorage.WriteAsync(System.String,System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
             <summary>
            
             </summary>
        </member>
        <member name="T:Storage.Net.ConnectionString.IConnectionFactory">
            <summary>
            Connection factory is responsible for creating storage instances from connection strings. It
            is usually implemented by every external module, however is optional.
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.IConnectionFactory.CreateBlobStorage(Storage.Net.ConnectionString.StorageConnectionString)">
            <summary>
            Creates a blob storage instance from connection string if possible. When this factory does not support this connection
            string it returns null.
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.IConnectionFactory.CreateMessenger(Storage.Net.ConnectionString.StorageConnectionString)">
            <summary>
            Creates a message publisher
            </summary>
        </member>
        <member name="T:Storage.Net.ConnectionString.StorageConnectionString">
            <summary>
            Holds a parsed connection string to the storage
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.StorageConnectionString.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.ConnectionString.StorageConnectionString"/>
            </summary>
            <param name="connectionString"></param>
        </member>
        <member name="P:Storage.Net.ConnectionString.StorageConnectionString.Item(System.String)">
            <summary>
            Gets or sets connection string parameters
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Storage.Net.ConnectionString.StorageConnectionString.IsNative">
            <summary>
            Determines if this is a native connection string
            </summary>
        </member>
        <member name="P:Storage.Net.ConnectionString.StorageConnectionString.Native">
            <summary>
            Returns native connection string, or null if connection string is not native
            </summary>
        </member>
        <member name="P:Storage.Net.ConnectionString.StorageConnectionString.ConnectionString">
            <summary>
            Original connection string
            </summary>
        </member>
        <member name="P:Storage.Net.ConnectionString.StorageConnectionString.Parameters">
            <summary>
            Connection string parameters exposed as key-value pairs
            </summary>
        </member>
        <member name="P:Storage.Net.ConnectionString.StorageConnectionString.Prefix">
            <summary>
            Prefix of this connection string, excluding prefix separator, i.e. for 'disk://something' the prefix is 'disk'
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.StorageConnectionString.GetRequired(System.String,System.Boolean,System.String@)">
            <summary>
            Gets the value of the parameter as when it's required. When parameter is not present, throws standard <see cref="T:System.ArgumentException"/>
            </summary>
            <param name="parameterName">Parameter name</param>
            <param name="requireNonEmptyValue">When true, checks that parameter value is not null or empty and throws <see cref="T:System.ArgumentException"/></param>
            <param name="value">Result value</param>
        </member>
        <member name="M:Storage.Net.ConnectionString.StorageConnectionString.Get(System.String)">
            <summary>
            Get connection string parameter by name
            </summary>
            <param name="parameterName"></param>
            <returns>Parameter value. If parameter is not set returns null.</returns>
        </member>
        <member name="M:Storage.Net.ConnectionString.StorageConnectionString.ToString">
            <summary>
            Returns a string representation of the connection string
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.EmptyTransaction">
            <summary>
            Transaction object which doesn't actually do anything
            </summary>
        </member>
        <member name="P:Storage.Net.EmptyTransaction.Instance">
            <summary>
            Returns empty transaction instance
            </summary>
        </member>
        <member name="P:Storage.Net.EmptyTransaction.TaskInstance">
            <summary>
            Returns empty transaction instance
            </summary>
        </member>
        <member name="M:Storage.Net.EmptyTransaction.CommitAsync">
            <summary>
            Doesn't do anything
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.EmptyTransaction.Dispose">
            <summary>
            Doesnt do anything
            </summary>
        </member>
        <member name="T:Storage.Net.ErrorCode">
            <summary>
            Generic error codes for storage operations
            </summary>
        </member>
        <member name="F:Storage.Net.ErrorCode.Unknown">
            <summary>
            Unknown error code
            </summary>
        </member>
        <member name="F:Storage.Net.ErrorCode.NotFound">
            <summary>
            Resource not found
            </summary>
        </member>
        <member name="F:Storage.Net.ErrorCode.DuplicateKey">
            <summary>
            Operation failed because a key already exists
            </summary>
        </member>
        <member name="F:Storage.Net.ErrorCode.Conflict">
            <summary>
            A conflict
            </summary>
        </member>
        <member name="T:Storage.Net.Factory">
            <summary>
            Factory extension methods
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.Use(Storage.Net.IModulesFactory,Storage.Net.IExternalModule)">
            <summary>
            Call to initialise a module
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.FromConnectionString(Storage.Net.IBlobStorageFactory,System.String)">
            <summary>
            Creates a blob storage instance from a connection string
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.MessengerFromConnectionString(Storage.Net.IMessagingFactory,System.String)">
            <summary>
            Creates message publisher
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.DirectoryFiles(Storage.Net.IBlobStorageFactory,System.String)">
            <summary>
            Creates an instance in a specific disk directory
            <param name="factory"></param>
            <param name="directoryFullName">Root directory</param>
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.ZipFile(Storage.Net.IBlobStorageFactory,System.String)">
            <summary>
            Zip file
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.InMemory(Storage.Net.IBlobStorageFactory)">
            <summary>
            Creates an instance of blob storage which stores everyting in memory. Useful for testing purposes only or if blobs don't
            take much space.
            </summary>
            <param name="factory">Factory reference</param>
            <returns>In-memory blob storage instance</returns>
        </member>
        <member name="M:Storage.Net.Factory.Virtual(Storage.Net.IBlobStorageFactory)">
            <summary>
            Creates a virtual storage where you can mount other storage providers to a specific virtual directory
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Factory.InMemory(Storage.Net.IMessagingFactory,System.String)">
            <summary>
            Creates a message publisher which holds messages in memory.
            </summary>
            <param name="factory"></param>
            <param name="name">Memory buffer name. Publishers with the same name will contain identical messages. Querying a publisher again
            with the same name returns an identical publisher. To create a receiver for this memory bufffer use the same name.</param>
        </member>
        <member name="M:Storage.Net.Factory.Disk(Storage.Net.IMessagingFactory,System.String)">
            <summary>
            Creates a message publisher that uses local disk directory as a backing store
            </summary>
            <param name="factory"></param>
            <param name="path">Path to directory to use as a backing store. If it doesn't exist, it will be created.</param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Factory.HandleLargeContent(Storage.Net.Messaging.IMessenger,Storage.Net.Blobs.IBlobStorage,System.Int32,System.Func{Storage.Net.Messaging.QueueMessage,System.String})">
            <summary>
            Wraps message publisher so that if it's content is larger than <paramref name="minSizeLarge"/>, the content is uploaded
            to blob storage and cleared on the message itself. The message is then stamped with a property <see cref="F:Storage.Net.Messaging.QueueMessage.LargeMessageContentHeaderName"/>
            which contains blob path of the message content.
            </summary>
            <param name="messenger">Message publisher to wrap</param>
            <param name="offloadStorage">Blob storage used to offload the message content</param>
            <param name="minSizeLarge">Threshold size</param>
            <param name="blobPathGenerator">Optional generator for blob path used to save large message content.</param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Factory.WithSinks(Storage.Net.Blobs.IBlobStorage,Storage.Net.Blobs.Sinks.ITransformSink[])">
            <summary>
            
            </summary>
            <param name="blobStorage"></param>
            <param name="sinks"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Factory.WithGzipCompression(Storage.Net.Blobs.IBlobStorage,System.IO.Compression.CompressionLevel)">
            <summary>
            Wraps blob storage into zip compression
            </summary>
            <param name="blobStorage"></param>
            <param name="compressionLevel"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Factory.WithSymmetricEncryption(Storage.Net.Blobs.IBlobStorage,System.String)">
            <summary>
            
            </summary>
            <param name="blobStorage"></param>
            <param name="encryptionKey"></param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.GenericValidation">
            <summary>
            A collection of generic library wise validations
            </summary>
        </member>
        <member name="M:Storage.Net.GenericValidation.CheckBlobPrefix(System.String)">
            <summary>
            Validates blob prefix search
            </summary>
            <param name="prefix"></param>
        </member>
        <member name="M:Storage.Net.GenericValidation.CheckBlobFullPath(System.String)">
            <summary>
            Validates blob full path
            </summary>
            <param name="fullPath"></param>
        </member>
        <member name="M:Storage.Net.GenericValidation.CheckBlobFullPaths(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Checks blob full path for generic rules
            </summary>
        </member>
        <member name="M:Storage.Net.GenericValidation.CheckBlobFullPaths(System.Collections.Generic.IEnumerable{Storage.Net.Blobs.Blob})">
            <summary>
            Checks blob full path for generic rules
            </summary>
        </member>
        <member name="M:Storage.Net.GenericValidation.CheckSourceStream(System.IO.Stream)">
            <summary>
            Checks source stream for generic rules
            </summary>
        </member>
        <member name="T:Storage.Net.IExternalModule">
            <summary>
            An entry point for implementing initialisation of an external module
            </summary>
        </member>
        <member name="P:Storage.Net.IExternalModule.ConnectionFactory">
            <summary>
            Gets connection factory
            </summary>
        </member>
        <member name="T:Storage.Net.ITransaction">
            <summary>
            Transaction abstraction
            </summary>
        </member>
        <member name="M:Storage.Net.ITransaction.CommitAsync">
            <summary>
            Commits the transaction
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.IVirtualStorage">
            <summary>
            Virtual storage
            </summary>
        </member>
        <member name="M:Storage.Net.IVirtualStorage.Mount(System.String,Storage.Net.Blobs.IBlobStorage)">
            <summary>
            Mounts a storage to virtual path
            </summary>
        </member>
        <member name="T:Storage.Net.KnownParameter">
            <summary>
            Known parameter names enouraged to be used in connection strings
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.Native">
            <summary>
            Indicates that this connection string is native
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.AccountName">
            <summary>
            Account or storage name
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.KeyOrPassword">
            <summary>
            Key or password
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.KeyId">
            <summary>
            Key ID
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.SessionToken">
            <summary>
            Session token
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.LocalProfileName">
            <summary>
            Name of a local profile
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.BucketName">
            <summary>
            Bucket name
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.Region">
            <summary>
            Region
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.UseDevelopmentStorage">
            <summary>
            
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.VaultUri">
            <summary>
            
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.TenantId">
            <summary>
            
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.ClientId">
            <summary>
            
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.ClientSecret">
            <summary>
            
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.MsiEnabled">
            <summary>
            
            </summary>
        </member>
        <member name="F:Storage.Net.KnownParameter.IsLocalEmulator">
            <summary>
            
            </summary>
        </member>
        <member name="T:Storage.Net.KnownPrefix">
            <summary>
            Known storage account prefixes
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AwsS3">
            <summary>
            Amazon S3
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.Databricks">
            <summary>
            Databricks on Azure or AWS
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AzureDataLakeGen1">
            <summary>
            Azure Data Lake Gen 1
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AzureDataLakeGen2">
            <summary>
            Azure Data Lake Gen 2
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AzureDataLake">
            <summary>
            Azure Data Lake latest generation, currently Gen 2
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AzureKeyVault">
            <summary>
            Azure Key Vault
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AzureBlobStorage">
            <summary>
            Azure Blob Storage
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AzureEventHub">
            <summary>
            Azure Event Hubs
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AzureFilesStorage">
            <summary>
            Azure File Storage
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AzureTableStorage">
            <summary>
            Microsoft Azure Table Storage
            </summary>
        </member>
        <member name="F:Storage.Net.KnownPrefix.AzureQueueStorage">
            <summary>
            Azure Storage Queues
            </summary>
        </member>
        <member name="T:Storage.Net.Messaging.Files.LocalDiskMessenger">
            <summary>
            Messages themselves can be human readable. THe speed is not an issue because the main bottleneck is disk anyway.
            </summary>
        </member>
        <member name="T:Storage.Net.Messaging.IMessageProcessor">
            <summary>
            Message processing interface used to register a callback that receives a message
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageProcessor.ProcessMessagesAsync(System.Collections.Generic.IReadOnlyCollection{Storage.Net.Messaging.QueueMessage})">
            <summary>
            
            </summary>
            <param name="messages"></param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Messaging.IMessageReceiver">
            <summary>
            Responsible for receiving messages
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.GetMessageCountAsync">
            <summary>
            Fetches count of messages currently in the queue.
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown when this implementation doesn't support counting.</exception>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.ConfirmMessagesAsync(System.Collections.Generic.IReadOnlyCollection{Storage.Net.Messaging.QueueMessage},System.Threading.CancellationToken)">
            <summary>
            Confirmation call that the message was acknowledged and processed by the receiver.
            Client must call this when message processing has succeeded, otherwise the message will reappear,
            however this depends on implementation details when and how.
            </summary>
            <param name="messages"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.DeadLetterAsync(Storage.Net.Messaging.QueueMessage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Moves the message to a dead letter queue
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.PeekMessagesAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Peeks messages from the queue, without changing their visibility or removing from the queue.
            </summary>
            <param name="maxMessages">Maximum number of messages to peek.</param>
            <param name="cancellationToken"></param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown when peeking is not supported by the current provider</exception>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.StartMessagePumpAsync(System.Func{System.Collections.Generic.IReadOnlyCollection{Storage.Net.Messaging.QueueMessage},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Starts automatic message pumping trying to use native features as much as possible. Message pump stops when you dispose the instance.
            Disposing the instance will also stop message pump for you.
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.KeepAliveAsync(Storage.Net.Messaging.QueueMessage,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Notifies the backend that processing is still happening and message should be marked alive.
            </summary>
            <param name="message"></param>
            <param name="timeToLive">Optional time-to-live</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.OpenTransactionAsync">
            <summary>
            Starts a new transaction
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Messaging.IMessenger">
            <summary>
            Messenger interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.IMessenger.CreateChannelsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Create one or more channels
            </summary>
            <param name="channelNames"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.IMessenger.ListChannelsAsync(System.Threading.CancellationToken)">
            <summary>
            List available channels
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.IMessenger.DeleteChannelsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Physically deletes channels
            </summary>
            <param name="channelNames"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.IMessenger.GetMessageCountAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Gets message count in a channel.
            </summary>
            <param name="channelName"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.IMessenger.SendAsync(System.String,System.Collections.Generic.IEnumerable{Storage.Net.Messaging.QueueMessage},System.Threading.CancellationToken)">
            <summary>
            Send messages to a channel
            </summary>
            <param name="channelName"></param>
            <param name="messages"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.IMessenger.ReceiveAsync(System.String,System.Int32,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            Receive messages from a channel
            </summary>
            <param name="channelName"></param>
            <param name="count"></param>
            <param name="visibility"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.IMessenger.PeekAsync(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Peek messages in a channel
            </summary>
            <param name="channelName"></param>
            <param name="count"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.IMessenger.DeleteAsync(System.String,System.Collections.Generic.IEnumerable{Storage.Net.Messaging.QueueMessage},System.Threading.CancellationToken)">
            <summary>
            Deletes messages from the channel
            </summary>
            <param name="channelName"></param>
            <param name="messages"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.IMessenger.StartMessageProcessorAsync(System.String,Storage.Net.Messaging.IMessageProcessor)">
            <summary>
            Starts message processor which listens for new messages asynchronously and passes to the processing host.
            </summary>
            <param name="channelName">Name of the channel</param>
            <param name="messageProcessor">Message processor implementation</param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Messaging.MessengerExtensions">
            <summary>
            Extensions for <see cref="T:Storage.Net.Messaging.IMessenger"/>
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.MessengerExtensions.CreateChannelAsync(Storage.Net.Messaging.IMessenger,System.String,System.Threading.CancellationToken)">
            <summary>
            Create a channel
            </summary>
            <param name="messenger"></param>
            <param name="channelName"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.MessengerExtensions.SendAsync(Storage.Net.Messaging.IMessenger,System.String,Storage.Net.Messaging.QueueMessage,System.Threading.CancellationToken)">
            <summary>
            Puts a new message to the back of the queue.
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.MessengerExtensions.DeleteChannelAsync(Storage.Net.Messaging.IMessenger,System.String,System.Threading.CancellationToken)">
            <summary>
            Deletes a single channel
            </summary>
            <param name="messenger"></param>
            <param name="channelName"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Messaging.PollingMessageReceiver">
            <summary>
            Base class for implementing a polling message receiver for those providers that do not support polling natively.
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.#ctor">
             <summary>
            
             </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.GetMessageCountAsync">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.ConfirmMessagesAsync(System.Collections.Generic.IReadOnlyCollection{Storage.Net.Messaging.QueueMessage},System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.DeadLetterAsync(Storage.Net.Messaging.QueueMessage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.Dispose">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.OpenTransactionAsync">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.StartMessagePumpAsync(System.Func{System.Collections.Generic.IReadOnlyCollection{Storage.Net.Messaging.QueueMessage},System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.ReceiveMessagesAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.KeepAliveAsync(Storage.Net.Messaging.QueueMessage,System.Nullable{System.TimeSpan},System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.PeekMessagesAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            see interface
            </summary>
            <param name="maxMessages"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Messaging.QueueMessage">
            <summary>
            Message to be used in all the queueing code
            </summary>
        </member>
        <member name="F:Storage.Net.Messaging.QueueMessage.LargeMessageContentHeaderName">
            <summary>
            Message header that points to large message content, if you are using content offloading feature
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.#ctor(System.String,System.String)">
            <summary>
            Creates an instance of <see cref="T:Storage.Net.Messaging.QueueMessage"/>
            </summary>
            <param name="id">Message ID</param>
            <param name="content">Message content</param>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.#ctor(System.String,System.Byte[])">
            <summary>
            Creates an instance of <see cref="T:Storage.Net.Messaging.QueueMessage"/>
            </summary>
            <param name="id">Message ID</param>
            <param name="content">Message content</param>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.#ctor(System.String)">
            <summary>
            Create queue message from message content
            </summary>
            <param name="content"></param>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.#ctor(System.Byte[])">
            <summary>
            Create queue message from message content
            </summary>
            <param name="content"></param>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.FromText(System.String)">
            <summary>
            Creates a new queue message from a text string
            </summary>
            <param name="text">Text to set as message content</param>
            <returns>New queue message</returns>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.Id">
            <summary>
            Message ID
            </summary>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.DequeueCount">
            <summary>
            Gets the count of how many time this message was dequeued
            </summary>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.NextVisibleTime">
            <summary>
            When present, indicates time when this message becomes visible again
            </summary>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.StringContent">
            <summary>
            Message content as string
            </summary>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.Content">
            <summary>
            Message content as byte array
            </summary>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.Properties">
            <summary>
            Extra properties for this message
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.Clone">
            <summary>
            Clones the message
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.ToByteArray">
            <summary>
            Extremely compact binary representation of the message.
            It's library specific, therefore try not to use it if portability is required.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.FromByteArray(System.Byte[])">
            <summary>
            Constructs the message back from compact representation
            </summary>
            <param name="data">Binary data</param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Model.MimeType">
            <summary>
            Common mime types. 
            </summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXJavascript">
            <summary>Used to denote the encoding necessary for files containing JavaScript source code. The alternative MIME type for this file type is text/javascript.</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioL24">
            <summary>24bit Linear PCM audio at 8-48kHz, 1-N channels; Defined in RFC 3190</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXShockwaveFlash">
            <summary>Adobe Flash files for example with the extension .swf</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationOctetStream">
            <summary>Arbitrary binary data.[5] Generally speaking this type identifies files that are not associated with a specific application. Contrary to past assumptions by software packages such as Apache this is not a type that should be applied to unknown files. In such a case, a server or application should not indicate a content type, as it may be incorrect, but rather, should omit the type in order to allow the recipient to guess the type.[6]</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationAtomXml">
            <summary>Atom feeds</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.TextCss">
            <summary>Cascading Style Sheets; Defined in RFC 2318</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.TextCmd">
            <summary>commands; subtype resident in Gecko browsers like Firefox 3.5</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.TextCsv">
            <summary>Comma-separated values; Defined in RFC 4180</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXDeb">
            <summary>deb (file format), a software package format used by the Debian project</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MultipartEncrypted">
            <summary>Defined in RFC 1847</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MultipartSigned">
            <summary>Defined in RFC 1847</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MessageHttp">
            <summary>Defined in RFC 2616</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ModelExample">
            <summary>Defined in RFC 4735</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXDvi">
            <summary>device-independent document in DVI format</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXmlDtd">
            <summary>DTD files; Defined by RFC 3023</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationJavascript">
            <summary>
            ECMAScript/JavaScript; Defined in RFC 4329 (equivalent to application/ecmascript but with looser processing rules) It is not accepted in IE 8 or earlier - text/javascript is accepted but it is defined as obsolete in RFC 4329. The "type" attribute of the script tag in HTML5 is optional and in practice omitting the media type of JavaScript programs is the most interoperable solution since all browsers have always assumed the correct default even before HTML5.
            </summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationEcmascript">
            <summary>ECMAScript/JavaScript; Defined in RFC 4329 (equivalent to application/javascript but with stricter processing rules)</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationEdifact">
            <summary>EDI EDIFACT data; Defined in RFC 1767</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationEdiX12">
            <summary>EDI X12 data; Defined in RFC 1767</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MessagePartial">
            <summary>Email; Defined in RFC 2045 and RFC 2046</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MessageRfc822">
            <summary>Email; EML files, MIME files, MHT files, MHTML files; Defined in RFC 2045 and RFC 2046</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.TextXml">
            <summary>Extensible Markup Language; Defined in RFC 3023</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.VideoXFlv">
            <summary>Flash video (FLV files)</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ImageGif">
            <summary>GIF image; Defined in RFC 2045 and RFC 2046</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.TextXGwtRpc">
            <summary>GoogleWebToolkit data</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXGzip">
            <summary>Gzip</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.TextHtml">
            <summary>HTML; Defined in RFC 2854</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ImageVndMicrosoftIcon">
            <summary>ICO image; Registered[9]</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ModelIges">
            <summary>IGS files, IGES files; Defined in RFC 2077</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MessageImdnXml">
            <summary>IMDN Instant Message Disposition Notification; Defined in RFC 5438</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationJson">
            <summary>JavaScript Object Notation JSON; Defined in RFC 4627</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationJsonPatch">
            <summary>JavaScript Object Notation (JSON) Patch; Defined in RFC 6902</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ImagePjpeg">
            <summary>JPEG JFIF image; Associated with Internet Explorer; Listed in ms775147(v=vs.85) - Progressive JPEG, initiated before global browser support for progressive JPEGs (Microsoft and Firefox).</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ImageJpeg">
            <summary>JPEG JFIF image; Defined in RFC 2045 and RFC 2046</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.TextXJqueryTmpl">
            <summary>jQuery template data</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndGoogleEarthKmlXml">
            <summary>KML files (e.g. for Google Earth)</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXLatex">
            <summary>LaTeX files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.VideoXMatroska">
            <summary>Matroska open media format</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndOpenxmlformatsOfficedocumentSpreadsheetmlSheet">
            <summary>Microsoft Excel 2007 files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndMsExcel">
            <summary>Microsoft Excel files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndOpenxmlformatsOfficedocumentPresentationmlPresentation">
            <summary>Microsoft Powerpoint 2007 files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndMsPowerpoint">
            <summary>Microsoft Powerpoint files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndOpenxmlformatsOfficedocumentWordprocessingmlDocument">
            <summary>Microsoft Word 2007 files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationMsword">
            <summary>Microsoft Word files[15]</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MultipartAlternative">
            <summary>MIME Email; Defined in RFC 2045 and RFC 2046</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MultipartMixed">
            <summary>MIME Email; Defined in RFC 2045 and RFC 2046</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MultipartRelated">
            <summary>MIME Email; Defined in RFC 2387 and used by MHTML (HTML mail)</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.MultipartFormData">
            <summary>MIME Webform; Defined in RFC 2388</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndMozillaXulXml">
            <summary>Mozilla XUL files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioMpeg">
            <summary>MP3 or other MPEG audio; Defined in RFC 3003</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioMp4">
            <summary>MP4 audio</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.VideoMp4">
            <summary>MP4 video; Defined in RFC 4337</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.VideoMpeg">
            <summary>MPEG-1 video with multiplexed audio; Defined in RFC 2045 and RFC 2046</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ModelMesh">
            <summary>MSH files, MESH files; Defined in RFC 2077, SILO files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioBasic">
            <summary>mulaw audio at 8 kHz, 1 channel; Defined in RFC 2046</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.VideoOgg">
            <summary>Ogg Theora or other video (with audio); Defined in RFC 5334</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioOgg">
            <summary>Ogg Vorbis, Speex, Flac and other audio; Defined in RFC 5334</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationOgg">
            <summary>Ogg, a multimedia bitstream container format; Defined in RFC 5334</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXopXml">
            <summary>OP</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndOasisOpendocumentGraphics">
            <summary>OpenDocument Graphics; Registered[14]</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndOasisOpendocumentPresentation">
            <summary>OpenDocument Presentation; Registered[13]</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndOasisOpendocumentSpreadsheet">
            <summary>OpenDocument Spreadsheet; Registered[12]</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationVndOasisOpendocumentText">
            <summary>OpenDocument Text; Registered[11]</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXPkcs12">
            <summary>p12 files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXPkcs7Certificates">
            <summary>p7b and spc files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXPkcs7Mime">
            <summary>p7c files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXPkcs7Certreqresp">
            <summary>p7r files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXPkcs7Signature">
            <summary>p7s files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationPdf">
            <summary>Portable Document Format, PDF has been in use for document exchange on the Internet since 1993; Defined in RFC 3778</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ImagePng">
            <summary>Portable Network Graphics; Registered,[8] Defined in RFC 2083</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationPostscript">
            <summary>PostScript; Defined in RFC 2046</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.VideoQuicktime">
            <summary>QuickTime video; Registered[10]</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXRarCompressed">
            <summary>RAR archive files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioVndRnRealaudio">
            <summary>RealAudio; Documented in RealPlayer Customer Support Answer 2559</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationRdfXml">
            <summary>Resource Description Framework; Defined by RFC 3870</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationRssXml">
            <summary>RSS feeds</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationSoapXml">
            <summary>SOAP; Defined by RFC 3902</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXStuffit">
            <summary>StuffIt archive files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ImageSvgXml">
            <summary>SVG vector image; Defined in SVG Tiny 1.2 Specification Appendix M</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ImageTiff">
            <summary>Tag Image File Format (only for Baseline TIFF); Defined in RFC 3302</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXTar">
            <summary>Tarball files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.TextPlain">
            <summary>Textual data; Defined in RFC 2046 and RFC 3676</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXFontTtf">
            <summary>TrueType Font No registered MIME type, but this is the most commonly used</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.TextVcard">
            <summary>vCard (contact information); Defined in RFC 6350</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioVorbis">
            <summary>Vorbis encoded audio; Defined in RFC 5215</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioVndWave">
            <summary>WAV audio; Defined in RFC 2361</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationFontWoff">
            <summary>Web Open Font Format; (candidate recommendation; use application/x-font-woff until standard is official)</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.VideoWebm">
            <summary>WebM Matroska-based open media format</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioWebm">
            <summary>WebM open media format</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioXMsWax">
            <summary>Windows Media Audio Redirector; Documented in Microsoft help page</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.AudioXMsWma">
            <summary>Windows Media Audio; Documented in Microsoft KB 288102</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.VideoXMsWmv">
            <summary>Windows Media Video; Documented in Microsoft KB 288102</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ModelVrml">
            <summary>WRL files, VRML files; Defined in RFC 2077</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ModelX3DXml">
            <summary>X3D ISO standard for representing 3D computer graphics, X3D XML files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ModelX3DBinary">
            <summary>X3D ISO standard for representing 3D computer graphics, X3DB binary files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ModelX3DVrml">
            <summary>X3D ISO standard for representing 3D computer graphics, X3DV VRML files</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationXhtmlXml">
            <summary>XHTML; Defined by RFC 3236</summary>
        </member>
        <member name="F:Storage.Net.Model.MimeType.ApplicationZip">
            <summary>ZIP archive files; Registered[7]</summary>
        </member>
        <member name="T:Storage.Net.StorageEventSource">
            <summary>
            Internal logger
            </summary>
        </member>
        <member name="P:Storage.Net.StorageEventSource.Log">
            <summary>
            Logger instance
            </summary>
        </member>
        <member name="M:Storage.Net.StorageEventSource.Debug(System.String,System.String)">
            <summary>
            Writes generic debug message
            </summary>
            <param name="subsystem"></param>
            <param name="message"></param>
        </member>
        <member name="M:Storage.Net.StorageEventSource.Error(System.String,System.String)">
            <summary>
            Writes generic error message
            </summary>
            <param name="subsystem"></param>
            <param name="message"></param>
        </member>
        <member name="T:Storage.Net.StorageException">
            <summary>
            Generic storage exception
            </summary>
        </member>
        <member name="M:Storage.Net.StorageException.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.StorageException"/>
            </summary>
        </member>
        <member name="M:Storage.Net.StorageException.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.StorageException"/> with exception message
            </summary>
        </member>
        <member name="M:Storage.Net.StorageException.#ctor(Storage.Net.ErrorCode,System.Exception)">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.StorageException"/> by error code
            </summary>
        </member>
        <member name="M:Storage.Net.StorageException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.StorageException"/> with exception message and inner exception
            </summary>
        </member>
        <member name="P:Storage.Net.StorageException.ErrorCode">
            <summary>
            Indicates the error code for this exception
            </summary>
        </member>
        <member name="T:Storage.Net.StorageFactory">
            <summary>
            Helper syntax for creating instances of storage library objects
            </summary>
        </member>
        <member name="P:Storage.Net.StorageFactory.KeyValue">
            <summary>
            Access to creating tables
            </summary>
        </member>
        <member name="P:Storage.Net.StorageFactory.Blobs">
            <summary>
            Access to creating blobs
            </summary>
        </member>
        <member name="P:Storage.Net.StorageFactory.Messages">
            <summary>
            Access to creating messaging
            </summary>
        </member>
        <member name="P:Storage.Net.StorageFactory.Modules">
            <summary>
            Module initialisation
            </summary>
        </member>
        <member name="P:Storage.Net.StorageFactory.ConnectionStrings">
            <summary>
            Connection strings
            </summary>
        </member>
        <member name="T:Storage.Net.IBlobStorageFactory">
            <summary>
            Crates blob storage implementations
            </summary>
        </member>
        <member name="T:Storage.Net.IMessagingFactory">
            <summary>
            Creates messaging implementations
            </summary>
        </member>
        <member name="T:Storage.Net.IKeyValueStorageFactory">
            <summary>
            Crates table storage implementations
            </summary>
        </member>
        <member name="T:Storage.Net.IConnectionStringFactory">
            <summary>
            Creates connection strings, acts as a helper
            </summary>
        </member>
        <member name="T:Storage.Net.IModulesFactory">
            <summary>
            Module initialisation primitives
            </summary>
        </member>
        <member name="T:Storage.Net.StoragePath">
            <summary>
            Storage Path utilities
            </summary>
        </member>
        <member name="F:Storage.Net.StoragePath.PathSeparator">
            <summary>
            Character used to split paths 
            </summary>
        </member>
        <member name="F:Storage.Net.StoragePath.PathSeparatorString">
            <summary>
            Character used to split paths as a string value
            </summary>
        </member>
        <member name="F:Storage.Net.StoragePath.RootFolderPath">
            <summary>
            Returns '/'
            </summary>
        </member>
        <member name="F:Storage.Net.StoragePath.LevelUpFolderName">
            <summary>
            Folder name for leveling up the path
            </summary>
        </member>
        <member name="M:Storage.Net.StoragePath.Combine(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Combines parts of path
            </summary>
            <param name="parts"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.StoragePath.GetParent(System.String)">
            <summary>
            Gets parent path of this item.
            </summary>
        </member>
        <member name="M:Storage.Net.StoragePath.Combine(System.String[])">
            <summary>
            Combines parts of path
            </summary>
            <param name="parts"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.StoragePath.Normalize(System.String,System.Boolean)">
            <summary>
            Normalizes path. Normalisation makes sure that:
            - When path is null or empty returns root path '/'
            - path separators are trimmed from both ends
            </summary>
            <param name="path"></param>
            <param name="removeTrailingSlash"></param>
        </member>
        <member name="M:Storage.Net.StoragePath.NormalizePart(System.String)">
            <summary>
            Normalizes path part
            </summary>
            <param name="part"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.StoragePath.Split(System.String)">
            <summary>
            Splits path in parts. Leading and trailing path separators are totally ignored. Note that it returns
            null if input path is null. Parent folder signatures are returned as a part of split, they are not removed.
            If you want to get an absolute normalized path use <see cref="M:Storage.Net.StoragePath.Normalize(System.String,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Storage.Net.StoragePath.IsRootPath(System.String)">
            <summary>
            Checks if path is root folder path, which can be an empty string, null, or the actual root path.
            </summary>
        </member>
        <member name="M:Storage.Net.StoragePath.GetRootFolder(System.String)">
            <summary>
            Gets the root folder name
            </summary>
        </member>
        <member name="M:Storage.Net.StoragePath.RemoveRootFolder(System.String)">
            <summary>
            Removes root folder from path
            </summary>
        </member>
        <member name="M:Storage.Net.StoragePath.ComparePath(System.String,System.String)">
            <summary>
            Compare that two path entries are equal. This takes into account path entries which are slightly different as strings but identical in physical location.
            </summary>
        </member>
        <member name="M:Storage.Net.StoragePath.Rename(System.String,System.String)">
            <summary>
            Replace file name
            </summary>
            <param name="path"></param>
            <param name="newFileName"></param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Streaming.FixedStream">
            <summary>
            Fixes deficiencies in thrird party streaming impelmentations
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.#ctor(System.IO.Stream,System.Nullable{System.Int64},System.Func{Storage.Net.Streaming.FixedStream,System.Threading.Tasks.Task})">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.#ctor(System.IO.Stream,System.Nullable{System.Int64},System.Action{Storage.Net.Streaming.FixedStream})">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.Parent">
            <summary>
            Gets original parent stream
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.Tag">
            <summary>
            Gets or sets an optional tag
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.CanRead">
            <summary>
            Gets parent's <see cref="P:Storage.Net.Streaming.FixedStream.CanRead"/>
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.CanSeek">
            <summary>
            Gets parent's <see cref="P:Storage.Net.Streaming.FixedStream.CanSeek"/>
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.CanWrite">
            <summary>
            Gets parent's <see cref="P:Storage.Net.Streaming.FixedStream.CanWrite"/>
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.Length">
            <summary>
            Gets stream leanth by returning either length passed in the constructor, or parent's length, in that order.
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.Position">
            <summary>
            Gets or sets current potision. This counter is maintained internally and parent's position is not used.
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Flush">
            <summary>
            Flushes the parent
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads from parent and updates internal position counter
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeks on parent
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.SetLength(System.Int64)">
            <summary>
            Sets length on parent
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes to parent and updates the internal position.
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Dispose(System.Boolean)">
            <summary>
            Calls back dispose if passed in the constructor, and calls parent's dispose
            </summary>
            <param name="disposing"></param>
        </member>
    </members>
</doc>

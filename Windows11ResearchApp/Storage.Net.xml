<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Storage.Net</name>
    </assembly>
    <members>
        <member name="T:Storage.Net.Blob.BlobId">
            <summary>
            Blob item description
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.BlobId.Kind">
            <summary>
            Gets the kind of item
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.BlobId.FolderPath">
            <summary>
            Gets the folder path containing this item
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.BlobId.Id">
            <summary>
            Gets the id of this blob, uniqueue within the folder
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.BlobId.Meta">
            <summary>
            Contains blob metadata when known, optional.
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.BlobId.FullPath">
            <summary>
            Gets full path to this blob which is a combination of folder path and blob name
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.BlobId.Properties">
            <summary>
            Custom provider-specific properties
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.BlobId.#ctor(System.String,Storage.Net.Blob.BlobItemKind)">
            <summary>
            Create a new instance
            </summary>
            <param name="fullId"></param>
            <param name="kind"></param>
        </member>
        <member name="M:Storage.Net.Blob.BlobId.#ctor(System.String,System.String,Storage.Net.Blob.BlobItemKind)">
            <summary>
            Creates a new instance
            </summary>
            <param name="folderPath"></param>
            <param name="id"></param>
            <param name="kind"></param>
        </member>
        <member name="M:Storage.Net.Blob.BlobId.ToString">
            <summary>
            Full blob info, i.e type, id and path
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.BlobId.Equals(Storage.Net.Blob.BlobId)">
            <summary>
            Equality check
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Storage.Net.Blob.BlobId.Equals(System.Object)">
            <summary>
            Equality check
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Storage.Net.Blob.BlobId.GetHashCode">
            <summary>
            Hash code calculation
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.BlobId.op_Implicit(System.String)~Storage.Net.Blob.BlobId">
            <summary>
            Constructs a file blob by full ID
            </summary>
        </member>
        <member name="T:Storage.Net.Blob.BlobItemKind">
            <summary>
            Type of the blob item in the storage
            </summary>
        </member>
        <member name="F:Storage.Net.Blob.BlobItemKind.File">
            <summary>
            The file
            </summary>
        </member>
        <member name="F:Storage.Net.Blob.BlobItemKind.Folder">
            <summary>
            The folder
            </summary>
        </member>
        <member name="T:Storage.Net.Blob.BlobMeta">
            <summary>
            Contains basic metadata about a blob
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.BlobMeta.#ctor(System.Int64,System.String,System.Nullable{System.DateTimeOffset})">
            <summary>
            Creates an instance of blob metadata
            </summary>
            <param name="size">Blob size</param>
            <param name="md5">MD5 hash of the blob</param>
            <param name="lastModificationTime">Last modifiacation time when known</param>
        </member>
        <member name="P:Storage.Net.Blob.BlobMeta.Size">
            <summary>
            Blob size
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.BlobMeta.MD5">
            <summary>
            MD5 content hash of the blob. Note that this property can be null if underlying storage has
            no information about the hash.
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.BlobMeta.LastModificationTime">
            <summary>
            Last modification time when known
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.BlobMeta.Properties">
            <summary>
            Extra properties that are implementation specific and have no specification. Take an extra care when using these are they are not
            guaranteed to be present at all or change between implementaitons.
            </summary>
        </member>
        <member name="T:Storage.Net.Blob.BlobStorageExtensions">
            <summary>
            Blob storage on steroids. Takes in <see cref="T:Storage.Net.Blob.IBlobStorage"/> and adds a lot of extra useful operations on top we as
            normal people use every day.
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.ListFilesAsync(Storage.Net.Blob.IBlobStorage,Storage.Net.Blob.ListOptions,System.Threading.CancellationToken)">
            <summary>
            Returns the list of available files, excluding folders.
            </summary>
            <param name="provider"></param>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns>List of blob IDs</returns>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.ReadTextAsync(Storage.Net.Blob.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Reads blob content and converts to text in UTF-8 encoding
            </summary>
            <param name="provider"></param>
            <param name="id">Blob id</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.WriteTextAsync(Storage.Net.Blob.IBlobStorage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Converts text to blob content and writes to storage
            </summary>
            <param name="provider"></param>
            <param name="id">Blob id</param>
            <param name="text">Text to write, treated in UTF-8 encoding</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.ExistsAsync(Storage.Net.Blob.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Checksi if blobs exists in the storage
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.DeleteAsync(Storage.Net.Blob.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Deletes a single blob
            </summary>
            <param name="storage"></param>
            <param name="id"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.GetMetaAsync(Storage.Net.Blob.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Gets basic blob metadata
            </summary>
            <returns>Blob metadata or null if blob doesn't exist</returns>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.ReadToStreamAsync(Storage.Net.Blob.IBlobStorage,System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Downloads blob to a stream
            </summary>
            <param name="provider"></param>
            <param name="id">Blob ID, required</param>
            <param name="targetStream">Target stream to copy to, required</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when any parameter is null</exception>
            <exception cref="T:System.ArgumentException">Thrown when ID is too long. Long IDs are the ones longer than 50 characters.</exception>
            <exception cref="T:Storage.Net.StorageException">Thrown when blob does not exist, error code set to <see cref="F:Storage.Net.ErrorCode.NotFound"/></exception>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.ReadToFileAsync(Storage.Net.Blob.IBlobStorage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Downloads a blob to the local filesystem.
            </summary>
            <param name="provider"></param>
            <param name="id">Blob ID to download</param>
            <param name="filePath">Full path to the local file to be downloaded to. If the file exists it will be recreated wtih blob data.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.WriteFileAsync(Storage.Net.Blob.IBlobStorage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Uploads local file to the blob storage
            </summary>
            <param name="provider"></param>
            <param name="id">Blob ID to create or overwrite</param>
            <param name="filePath">Path to local file</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Storage.Net.Blob.BlobStorageExtensions.CopyToAsync(Storage.Net.Blob.IBlobStorage,System.String,Storage.Net.Blob.IBlobStorage,System.String,System.Threading.CancellationToken)">
            <summary>
            Copies blob to another storage
            </summary>
            <param name="provider"></param>
            <param name="blobId">Blob ID to copy</param>
            <param name="targetStorage">Target storage</param>
            <param name="newId">Optional, when specified uses this id in the target storage. If null uses the original ID.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="T:Storage.Net.Blob.Files.DiskDirectoryBlobStorage">
            <summary>
            Blob storage implementation which uses local file system directory
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Creates an instance in a specific disk directory
            <param name="directory">Root directory</param>
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.RootDirectory">
            <summary>
            Original root directory this storage is mapped to
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.ListAsync(Storage.Net.Blob.ListOptions,System.Threading.CancellationToken)">
            <summary>
            Returns the list of blob names in this storage, optionally filtered by prefix
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.Dispose">
            <summary>
            dispose
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.WriteAsync(System.String,System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Streams into file
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.OpenWriteAsync(System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.OpenReadAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Opens file and returns the open stream
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.DeleteAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Deletes files if they exist
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.ExistsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Checks if files exist on disk
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.GetMetaAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Gets file metadata
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.Files.DiskDirectoryBlobStorage.OpenTransactionAsync">
            <summary>
            Returns empty transaction as filesystem has no transaction support
            </summary>
        </member>
        <member name="T:Storage.Net.Blob.IBlobStorage">
            <summary>
            Slim interface providing access to blob storage.
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.IBlobStorage.ListAsync(Storage.Net.Blob.ListOptions,System.Threading.CancellationToken)">
            <summary>
            Returns the list of available blobs
            </summary>
            <param name="options"></param>
            <param name="cancellationToken"></param>
            <returns>List of blob IDs</returns>
        </member>
        <member name="M:Storage.Net.Blob.IBlobStorage.WriteAsync(System.String,System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new blob and uploads data intor it. If the blob already exists it will be
            overwritten.
            </summary>
            <param name="id">Blob ID</param>
            <param name="sourceStream">Source stream, must be readable and support Length</param>
            <param name="cancellationToken"></param>
            <param name="append">When true, appends to the file instead of writing a new one.</param>
            <returns>Writeable stream</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when any parameter is null</exception>
            <exception cref="T:System.ArgumentException">Thrown when ID is too long. Long IDs are the ones longer than 50 characters.</exception>
        </member>
        <member name="M:Storage.Net.Blob.IBlobStorage.OpenWriteAsync(System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new blob and opens a writeable stream for it. If the blob already exists it will be
            overwritten. Please note that <see cref="M:Storage.Net.Blob.IBlobStorage.WriteAsync(System.String,System.IO.Stream,System.Boolean,System.Threading.CancellationToken)"/> is always
            more effective than this method, because not all of the providers support holding a write stream natively and
            some will incur workaround options to support this.
            </summary>
            <param name="id">Blob ID</param>
            <param name="cancellationToken"></param>
            <param name="append">When true, appends to the file instead of writing a new one.</param>
            <returns>Writeable stream</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when any parameter is null</exception>
            <exception cref="T:System.ArgumentException">Thrown when ID is too long. Long IDs are the ones longer than 50 characters.</exception>
        </member>
        <member name="M:Storage.Net.Blob.IBlobStorage.OpenReadAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Opens the blob stream to read.
            </summary>
            <param name="id">Blob ID, required</param>
            <param name="cancellationToken"></param>
            <returns>Stream in an open state, or null if blob doesn't exist by this ID. It is your responsibility to close and dispose this
            stream after use.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown when any parameter is null</exception>
            <exception cref="T:System.ArgumentException">Thrown when ID is too long. Long IDs are the ones longer than 50 characters.</exception>
        </member>
        <member name="M:Storage.Net.Blob.IBlobStorage.DeleteAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Deletes a blob by id
            </summary>
            <param name="ids">Blob IDs to delete.</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ArgumentNullException">Thrown when ID is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when ID is too long. Long IDs are the ones longer than 50 characters.</exception>
        </member>
        <member name="M:Storage.Net.Blob.IBlobStorage.ExistsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Checksi if blobs exists in the storage
            </summary>
            <param name="ids">List of ids</param>
            <param name="cancellationToken"></param>
            <returns>List of results of true and false indicating existence</returns>
        </member>
        <member name="M:Storage.Net.Blob.IBlobStorage.GetMetaAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>
            Gets basic blob metadata
            </summary>
            <param name="ids">Blob id</param>
            <param name="cancellationToken"></param>
            <returns>Blob metadata or null if blob doesn't exist</returns>
        </member>
        <member name="M:Storage.Net.Blob.IBlobStorage.OpenTransactionAsync">
            <summary>
            Starts a new transaction
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Blob.ListOptions">
            <summary>
            Options for listing storage content
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.ListOptions.FolderPath">
            <summary>
            Folder path to start browsing from. When not set scanning starts from the root folder.
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.ListOptions.BrowseFilter">
            <summary>
            Gets or sets a browsing filter used by some implementations which can filter out results before returning it to you.
            This is useful to minimise amount of RAM taken when returning the results and then filtering them on client side.
            Note that filtering will be happening on the client side, therefore this is the least efficient filter and should
            only be used when you're concerned about RAM usage.
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.ListOptions.FilePrefix">
            <summary>
            Prefix to filter file name by. Folders are not affected by this filter. If you list files recursively
            the prefix is applied in every folder.
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.ListOptions.Recurse">
            <summary>
            When true, operation will recursively navigate down the folders.
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.ListOptions.MaxResults">
            <summary>
            When set, limits the maximum amount of results. The count affects all object counts, including files and folders.
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.ListOptions.IncludeMetaWhenKnown">
            <summary>
            When set, includes blob metadata in the response if the provider supports it. False by default
            only because metadata consumes more memory in response object, although most of the providers do not
            have any overhead in creating this metadata.
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.ListOptions.ListProgressCallback">
            <summary>
            When set, an implementing provider might be able to send notification on progress callback if it supports them.
            First parameter indicates number of items already listed, second - total number of items (if known).
            </summary>
        </member>
        <member name="P:Storage.Net.Blob.ListOptions.MaxDegreeOfParalellism">
            <summary>
            When supported, sets the maximum number of threads to be used for listing operations
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.ListOptions.IsMatch(Storage.Net.Blob.BlobId)">
            <summary>
            Helper method that returns true if a <see cref="T:Storage.Net.Blob.BlobId"/> matches these list options.
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.ListOptions.Add(System.Collections.Generic.ICollection{Storage.Net.Blob.BlobId},System.Collections.Generic.ICollection{Storage.Net.Blob.BlobId})">
            <summary>
            Only for internal use
            </summary>
        </member>
        <member name="M:Storage.Net.Blob.ListOptions.Clone">
            <summary>
            Clones list options
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.ConnectionString.IConnectionFactory">
            <summary>
            Connection factory is responsible for creating storage instances from connection strings. It
            is usually implemented by every external module, however is optional.
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.IConnectionFactory.CreateBlobStorage(Storage.Net.ConnectionString.StorageConnectionString)">
            <summary>
            Creates a blob storage instance from connection string if possible. When this factory does not support this connection
            string it returns null.
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.IConnectionFactory.CreateKeyValueStorage(Storage.Net.ConnectionString.StorageConnectionString)">
            <summary>
            Creates a key-value storage instance from connection string if possible. When this factory does not support this connection
            string it returns null.
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.IConnectionFactory.CreateMessagePublisher(Storage.Net.ConnectionString.StorageConnectionString)">
            <summary>
            Creates a message publisher
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.IConnectionFactory.CreateMessageReceiver(Storage.Net.ConnectionString.StorageConnectionString)">
            <summary>
            Creates a message receiver
            </summary>
        </member>
        <member name="T:Storage.Net.ConnectionString.StorageConnectionString">
            <summary>
            Holds a parsed connection string to the storage
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.StorageConnectionString.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.ConnectionString.StorageConnectionString"/>
            </summary>
            <param name="connectionString"></param>
        </member>
        <member name="P:Storage.Net.ConnectionString.StorageConnectionString.ConnectionString">
            <summary>
            Original connection string
            </summary>
        </member>
        <member name="P:Storage.Net.ConnectionString.StorageConnectionString.Prefix">
            <summary>
            Prefix of this connection string, excluding prefix separator, i.e. for 'disk://something' the prefix is 'disk'
            </summary>
        </member>
        <member name="M:Storage.Net.ConnectionString.StorageConnectionString.GetRequired(System.String,System.Boolean,System.String@)">
            <summary>
            Gets the value of the parameter as when it's required. When parameter is not present, throws standard <see cref="T:System.ArgumentException"/>
            </summary>
            <param name="parameterName">Parameter name</param>
            <param name="requireNonEmptyValue">When true, checks that parameter value is not null or empty and throws <see cref="T:System.ArgumentException"/></param>
            <param name="value">Result value</param>
        </member>
        <member name="M:Storage.Net.ConnectionString.StorageConnectionString.Get(System.String)">
            <summary>
            Get connection string parameter by name
            </summary>
            <param name="parameterName"></param>
            <returns>Parameter value. If parameter is not set returns an empty string</returns>
        </member>
        <member name="T:Storage.Net.EmptyTransaction">
            <summary>
            Transaction object which doesn't actually do anything
            </summary>
        </member>
        <member name="P:Storage.Net.EmptyTransaction.Instance">
            <summary>
            Returns empty transaction instance
            </summary>
        </member>
        <member name="M:Storage.Net.EmptyTransaction.CommitAsync">
            <summary>
            Doesn't do anything
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.EmptyTransaction.Dispose">
            <summary>
            Doesnt do anything
            </summary>
        </member>
        <member name="T:Storage.Net.ErrorCode">
            <summary>
            Generic error codes for storage operations
            </summary>
        </member>
        <member name="F:Storage.Net.ErrorCode.Unknown">
            <summary>
            Unknown error code
            </summary>
        </member>
        <member name="F:Storage.Net.ErrorCode.NotFound">
            <summary>
            Resource not found
            </summary>
        </member>
        <member name="F:Storage.Net.ErrorCode.DuplicateKey">
            <summary>
            Operation failed because a key already exists
            </summary>
        </member>
        <member name="T:Storage.Net.Exceptions">
            <summary>
               A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Storage.Net.Exceptions.ResourceManager">
            <summary>
               Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Storage.Net.Exceptions.Culture">
            <summary>
               Overrides the current thread's CurrentUICulture property for all
               resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Storage.Net.Exceptions.BlobId_TooLong">
            <summary>
               Looks up a localized string similar to blob ID cannot exceed {0} characters.
            </summary>
        </member>
        <member name="P:Storage.Net.Exceptions.BlobPrefix_TooLong">
            <summary>
               Looks up a localized string similar to blob prefix cannot exceed {0} characters.
            </summary>
        </member>
        <member name="T:Storage.Net.Factory">
            <summary>
            Factory extension methods
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.Use(Storage.Net.IModulesFactory,Storage.Net.IExternalModule)">
            <summary>
            Call to initialise a module
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.FromConnectionString(Storage.Net.IBlobStorageFactory,System.String)">
            <summary>
            Creates a blob stogage instance from a connection string
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.FromConnectionString(Storage.Net.IKeyValueStorageFactory,System.String)">
            <summary>
            Creates a key-value storage instance from a connections tring
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.PublisherFromConnectionString(Storage.Net.IMessagingFactory,System.String)">
            <summary>
            Creates message publisher
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.ReceiverFromConnectionString(Storage.Net.IMessagingFactory,System.String)">
            <summary>
            Creates message receiver
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.CsvFiles(Storage.Net.IKeyValueStorageFactory,System.IO.DirectoryInfo)">
            <summary>
            Creates a new instance of CSV file storage
            </summary>
            <param name="factory"></param>
            <param name="rootDir"></param>
        </member>
        <member name="M:Storage.Net.Factory.DirectoryFiles(Storage.Net.IBlobStorageFactory,System.IO.DirectoryInfo)">
            <summary>
            Creates an instance in a specific disk directory
            <param name="factory"></param>
            <param name="directory">Root directory</param>
            </summary>
        </member>
        <member name="M:Storage.Net.Factory.InMemory(Storage.Net.IBlobStorageFactory)">
            <summary>
            Creates an instance of blob storage which stores everyting in memory. Useful for testing purposes only or if blobs don't
            take much space.
            </summary>
            <param name="factory">Factory reference</param>
            <returns>In-memory blob storage instance</returns>
        </member>
        <member name="M:Storage.Net.Factory.InMemoryPublisher(Storage.Net.IMessagingFactory,System.String)">
            <summary>
            Creates a message publisher which holds messages in memory.
            </summary>
            <param name="factory"></param>
            <param name="name">Memory buffer name. Publishers with the same name will contain identical messages. Querying a publisher again
            with the same name returns an identical publisher. To create a receiver for this memory bufffer use the same name.</param>
        </member>
        <member name="M:Storage.Net.Factory.InMemoryReceiver(Storage.Net.IMessagingFactory,System.String)">
            <summary>
            Creates a message receiver to receive messages from a specified memory buffer.
            </summary>
            <param name="factory"></param>
            <param name="name">Memory buffer name. Use the name used when you've created a publisher to receive messages from that buffer.</param>
        </member>
        <member name="T:Storage.Net.GenericValidation">
            <summary>
            A collection of generic library wise validations
            </summary>
        </member>
        <member name="M:Storage.Net.GenericValidation.CheckBlobPrefix(System.String)">
            <summary>
            Validates blob prefix search
            </summary>
            <param name="prefix"></param>
        </member>
        <member name="M:Storage.Net.GenericValidation.CheckBlobId(System.String)">
            <summary>
            Validates blob ID
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Storage.Net.GenericValidation.CheckBlobId(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Checks blob ID for generic rules
            </summary>
        </member>
        <member name="M:Storage.Net.GenericValidation.CheckSourceStream(System.IO.Stream)">
            <summary>
            Checks source stream for generic rules
            </summary>
        </member>
        <member name="T:Storage.Net.IExternalModule">
            <summary>
            An entry point for implementing initialisation of an external module
            </summary>
        </member>
        <member name="P:Storage.Net.IExternalModule.ConnectionFactory">
            <summary>
            Gets connection factory
            </summary>
        </member>
        <member name="T:Storage.Net.ITransaction">
            <summary>
            Transaction abstraction
            </summary>
        </member>
        <member name="M:Storage.Net.ITransaction.CommitAsync">
            <summary>
            Commits the transaction
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage">
            <summary>
            Creates an abstaction of <see cref="T:Storage.Net.KeyValue.IKeyValueStorage"/> in a CSV file structure.
            Works relative to the root directory specified in the constructor.
            Each table will be a separate subfolder, where files are partitions.
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Creates a new instance of CSV file storage
            </summary>
            <param name="rootDir"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.HasOptimisticConcurrency">
            <summary>
            See interface documentation
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.ListTableNamesAsync">
            <summary>
            See interface documentation
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.DeleteAsync(System.String)">
            <summary>
            See interface documentation
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.GetAsync(System.String,Storage.Net.KeyValue.Key)">
            <summary>
            See interface documentation
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.InsertAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Value})">
            <summary>
            See interface documentation
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.InsertOrReplaceAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Value})">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.UpdateAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Value})">
            <summary>
            See interface documentation
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.MergeAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Value})">
            <summary>
            See interface documentation
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.DeleteAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Key})">
            <summary>
            See interface documentation
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.Get(System.String,System.String,System.String,System.Int32)">
            <summary>
            See interface documentation
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Files.CsvFileKeyValueStorage.Dispose">
            <summary>
            Does nothing as no handles are kept open
            </summary>
        </member>
        <member name="T:Storage.Net.KeyValue.IKeyValueStorage">
            <summary>
            Common interface for working with key-value storage
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.IKeyValueStorage.ListTableNamesAsync">
            <summary>
            Returns the list of all table names in the storage.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.KeyValue.IKeyValueStorage.DeleteAsync(System.String)">
            <summary>
            Deletes entire table. If table doesn't exist no errors are raised.
            </summary>
            <param name="tableName">Name of the table to delete. Passing null raises <see cref="T:System.ArgumentNullException"/></param>
        </member>
        <member name="M:Storage.Net.KeyValue.IKeyValueStorage.GetAsync(System.String,Storage.Net.KeyValue.Key)">
            <summary>
            Gets values by key
            </summary>
            <param name="tableName">Table name, required.</param>
            <param name="key">Row key to look up against. The key must have partition key populated, however row key is optional.
            When row key is not set, this method returns all of the values in a specifi</param>
            <returns>
            List of table values in the table's partition. This method never returns null and if no records
            are found an empty collection is returned.
            </returns>
        </member>
        <member name="M:Storage.Net.KeyValue.IKeyValueStorage.InsertAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Value})">
            <summary>
            Inserts values in the table.
            </summary>
            <param name="tableName">Table name, required.</param>
            <param name="values">values to insert, required. The values can belong to different partitions.</param>
            <exception cref="T:Storage.Net.StorageException">
            If the row already exists thvalues this exception with <see cref="F:Storage.Net.ErrorCode.DuplicateKey"/>.
            Note that exception is thrown only for partiton batch. If values contains more than one partition to insert
            some of them may succeed and some may fail.
            </exception>
        </member>
        <member name="M:Storage.Net.KeyValue.IKeyValueStorage.InsertOrReplaceAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Value})">
            <summary>
            Inserts values in the table, and if they exist replaces them with a new value.
            </summary>
            <param name="tableName">Table name, required.</param>
            <param name="values">values to insert, required. The values can belong to different partitions.</param>
            <exception cref="T:Storage.Net.StorageException">
            If input values have duplicated keys thvalues this exception with <see cref="F:Storage.Net.ErrorCode.DuplicateKey"/>
            </exception>
        </member>
        <member name="M:Storage.Net.KeyValue.IKeyValueStorage.UpdateAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Value})">
            <summary>
            Updates multiple values. Note that all the values must belong to the same partition.
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.IKeyValueStorage.MergeAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Value})">
            <summary>
            Merges multiple values. Note that all values must belong to the same partition
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.IKeyValueStorage.DeleteAsync(System.String,System.Collections.Generic.IReadOnlyCollection{Storage.Net.KeyValue.Key})">
            <summary>
            Deletes multiple values
            </summary>
        </member>
        <member name="T:Storage.Net.KeyValue.Key">
            <summary>
            ID structure of the <see cref="T:Storage.Net.KeyValue.Value"/>
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Key.#ctor(System.String,System.String)">
            <summary>
            Constructs an instance of <see cref="T:Storage.Net.KeyValue.Key"/>
            </summary>
            <param name="partitionKey">Partition key</param>
            <param name="rowKey">Row key</param>
        </member>
        <member name="P:Storage.Net.KeyValue.Key.PartitionKey">
            <summary>
            Partition key
            </summary>
        </member>
        <member name="P:Storage.Net.KeyValue.Key.RowKey">
            <summary>
            Row key
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Key.Equals(Storage.Net.KeyValue.Key)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Key.Equals(System.Object)">
            <summary>
            Equals
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Key.GetHashCode">
            <summary>
            Hash code
            </summary>
        </member>
        <member name="T:Storage.Net.KeyValue.KeyValueStorageExtensions">
            <summary>
            <see cref="T:Storage.Net.KeyValue.IKeyValueStorage"/> on steroids
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.KeyValueStorageExtensions.GetSingleAsync(Storage.Net.KeyValue.IKeyValueStorage,System.String,Storage.Net.KeyValue.Key)">
            <summary>
            Gets first value by key
            </summary>
            <param name="storage"></param>
            <param name="tableName"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.KeyValue.KeyValueStorageExtensions.GetSingleAsync(Storage.Net.KeyValue.IKeyValueStorage,System.String,System.String,System.String)">
            <summary>
            Gets first value by key
            </summary>
            <param name="storage"></param>
            <param name="tableName"></param>
            <param name="partitionKey"></param>
            <param name="rowKey"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.KeyValue.KeyValueStorageExtensions.DeleteAsync(Storage.Net.KeyValue.IKeyValueStorage,System.String,Storage.Net.KeyValue.Key)">
            <summary>
            Deletes record by key
            </summary>
        </member>
        <member name="T:Storage.Net.KeyValue.Value">
            <summary>
            Represents a table row in table data structure.
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.#ctor(System.String,System.String)">
            <summary>
            Creates a new instance from partition key and row key
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.#ctor(Storage.Net.KeyValue.Key)">
            <summary>
            Creates a new instance from <see cref="T:Storage.Net.KeyValue.Key"/>
            </summary>
            <param name="id"></param>
        </member>
        <member name="P:Storage.Net.KeyValue.Value.Id">
            <summary>
            Row ID
            </summary>
        </member>
        <member name="P:Storage.Net.KeyValue.Value.PartitionKey">
            <summary>
            Partition key
            </summary>
        </member>
        <member name="P:Storage.Net.KeyValue.Value.RowKey">
            <summary>
            Row key
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.Equals(Storage.Net.KeyValue.Value)">
            <summary>
            Checks row equality
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.GetEnumerator">
            <summary>
            Get enumerator for cells inside the row
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator for cells inside the row
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.Add(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            IDictionary.Add
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.Clear">
            <summary>
            Clears cells
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.Contains(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            IDictionary.Contains
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.Object}[],System.Int32)">
            <summary>
            IDictionary.CopyTo
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.Remove(System.Collections.Generic.KeyValuePair{System.String,System.Object})">
            <summary>
            IDictionary.Remove
            </summary>
        </member>
        <member name="P:Storage.Net.KeyValue.Value.Count">
            <summary>
            IDictionary.Count
            </summary>
        </member>
        <member name="P:Storage.Net.KeyValue.Value.IsReadOnly">
            <summary>
            IDictionary.IsReadOnly
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.Add(System.String,System.Object)">
            <summary>
            IDictionary.Add
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.ContainsKey(System.String)">
            <summary>
            IDictionary.ContainsKey
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.Remove(System.String)">
            <summary>
            IDictionary.Remove
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.TryGetValue(System.String,System.Object@)">
            <summary>
            IDictionary.TryGetValue
            </summary>
        </member>
        <member name="P:Storage.Net.KeyValue.Value.Item(System.String)">
            <summary>
            IDictionary.this
            </summary>
        </member>
        <member name="P:Storage.Net.KeyValue.Value.Keys">
            <summary>
            IDictionary.Keys
            </summary>
        </member>
        <member name="P:Storage.Net.KeyValue.Value.Values">
            <summary>
            IDictionary.Values
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.Clone(System.String,System.String)">
            <summary>
            Clones the row
            </summary>
            <param name="rowKey">When specified, the clone receives this value for the Row Key</param>
            <param name="partitionKey">When speified, the clone receives this value for the Partition Key</param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.ToString">
            <summary>
            Returns string representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.AreDistinct(System.Collections.Generic.IEnumerable{Storage.Net.KeyValue.Value})">
            <summary>
            Checks if all rows have uniqueue keys
            </summary>
        </member>
        <member name="M:Storage.Net.KeyValue.Value.Merge(System.Collections.Generic.IEnumerable{Storage.Net.KeyValue.Value})">
            <summary>
            Merge
            </summary>
        </member>
        <member name="T:Storage.Net.Queue.Files.DiskMessagePublisherReceiver">
            <summary>
            Messages themselves can be human readable. THe speed is not an issue because the main bottleneck is disk anyway.
            </summary>
        </member>
        <member name="T:Storage.Net.Messaging.IMessagePublisher">
            <summary>
            Responsible for publishing messages
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.IMessagePublisher.PutMessagesAsync(System.Collections.Generic.IEnumerable{Storage.Net.Messaging.QueueMessage},System.Threading.CancellationToken)">
            <summary>
            Puts a new batch of messages to the back of the queue as quick and efficient as possible for
            a given queue implementation.
            </summary>
        </member>
        <member name="T:Storage.Net.Messaging.IMessageReceiver">
            <summary>
            Responsible for receiving messages
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.GetMessageCountAsync">
            <summary>
            Fetches count of messages currently in the queue.
            </summary>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">Thrown when this implementation doesn't support counting.</exception>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.ConfirmMessagesAsync(System.Collections.Generic.IReadOnlyCollection{Storage.Net.Messaging.QueueMessage},System.Threading.CancellationToken)">
            <summary>
            Confirmation call that the message was acknowledged and processed by the receiver.
            Client must call this when message processing has succeeded, otherwise the message will reappear,
            however this depends on implementation details when and how.
            </summary>
            <param name="messages"></param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.DeadLetterAsync(Storage.Net.Messaging.QueueMessage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Moves the message to a dead letter queue
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.StartMessagePumpAsync(System.Func{System.Collections.Generic.IReadOnlyCollection{Storage.Net.Messaging.QueueMessage},System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
            <summary>
            Starts automatic message pumping trying to use native features as much as possible. Message pump stops when you dispose the instance.
            Disposing the instance will also stop message pump for you.
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.IMessageReceiver.OpenTransactionAsync">
            <summary>
            Starts a new transaction
            </summary>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.Messaging.MessagePublisherExtensions">
            <summary>
            Extensions for IMessagePublisher
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.MessagePublisherExtensions.PutMessageAsync(Storage.Net.Messaging.IMessagePublisher,Storage.Net.Messaging.QueueMessage)">
            <summary>
            Puts a new message to the back of the queue.
            </summary>
        </member>
        <member name="T:Storage.Net.Messaging.PollingMessageReceiver">
            <summary>
            Base class for implementing a polling message receiver for those providers that do not support polling natively.
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.GetMessageCountAsync">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.ConfirmMessagesAsync(System.Collections.Generic.IReadOnlyCollection{Storage.Net.Messaging.QueueMessage},System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.DeadLetterAsync(Storage.Net.Messaging.QueueMessage,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.Dispose">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.OpenTransactionAsync">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.StartMessagePumpAsync(System.Func{System.Collections.Generic.IReadOnlyCollection{Storage.Net.Messaging.QueueMessage},System.Threading.Tasks.Task},System.Int32,System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.PollingMessageReceiver.ReceiveMessagesAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            See interface
            </summary>
        </member>
        <member name="T:Storage.Net.Messaging.QueueMessage">
            <summary>
            Message to be used in all the queueing code
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.#ctor(System.String,System.String)">
            <summary>
            Creates an instance of <see cref="T:Storage.Net.Messaging.QueueMessage"/>
            </summary>
            <param name="id">Message ID</param>
            <param name="content">Message content</param>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.#ctor(System.String,System.Byte[])">
            <summary>
            Creates an instance of <see cref="T:Storage.Net.Messaging.QueueMessage"/>
            </summary>
            <param name="id">Message ID</param>
            <param name="content">Message content</param>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.#ctor(System.String)">
            <summary>
            Create queue message from message content
            </summary>
            <param name="content"></param>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.#ctor(System.Byte[])">
            <summary>
            Create queue message from message content
            </summary>
            <param name="content"></param>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.FromText(System.String)">
            <summary>
            Creates a new queue message from a text string
            </summary>
            <param name="text">Text to set as message content</param>
            <returns>New queue message</returns>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.Id">
            <summary>
            Message ID
            </summary>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.DequeueCount">
            <summary>
            Gets the count of how many time this message was dequeued
            </summary>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.StringContent">
            <summary>
            Message content as string
            </summary>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.Content">
            <summary>
            Message content as byte array
            </summary>
        </member>
        <member name="P:Storage.Net.Messaging.QueueMessage.Properties">
            <summary>
            Extra properties for this message
            </summary>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.Clone">
            <summary>
            Clones the message
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.ToByteArray">
            <summary>
            Extremely compact binary representation of the message.
            It's library specific, therefore try not to use it if portability is required.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.Messaging.QueueMessage.FromByteArray(System.Byte[])">
            <summary>
            Constructs the message back from compact representation
            </summary>
            <param name="data">Binary data</param>
            <returns></returns>
        </member>
        <member name="T:Storage.Net.StorageException">
            <summary>
            Generic storage exception
            </summary>
        </member>
        <member name="M:Storage.Net.StorageException.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.StorageException"/>
            </summary>
        </member>
        <member name="M:Storage.Net.StorageException.#ctor(System.String)">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.StorageException"/> with exception message
            </summary>
        </member>
        <member name="M:Storage.Net.StorageException.#ctor(Storage.Net.ErrorCode,System.Exception)">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.StorageException"/> by error code
            </summary>
        </member>
        <member name="M:Storage.Net.StorageException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new instance of <see cref="T:Storage.Net.StorageException"/> with exception message and inner exception
            </summary>
        </member>
        <member name="P:Storage.Net.StorageException.ErrorCode">
            <summary>
            Indicates the error code for this exception
            </summary>
        </member>
        <member name="T:Storage.Net.StorageFactory">
            <summary>
            Helper syntax for creating instances of storage library objects
            </summary>
        </member>
        <member name="P:Storage.Net.StorageFactory.KeyValue">
            <summary>
            Access to creating tables
            </summary>
        </member>
        <member name="P:Storage.Net.StorageFactory.Blobs">
            <summary>
            Access to creating blobs
            </summary>
        </member>
        <member name="P:Storage.Net.StorageFactory.Messages">
            <summary>
            Access to creating messaging
            </summary>
        </member>
        <member name="P:Storage.Net.StorageFactory.Modules">
            <summary>
            Module initialisation
            </summary>
        </member>
        <member name="T:Storage.Net.IBlobStorageFactory">
            <summary>
            Crates blob storage implementations
            </summary>
        </member>
        <member name="T:Storage.Net.IMessagingFactory">
            <summary>
            Creates messaging implementations
            </summary>
        </member>
        <member name="T:Storage.Net.IKeyValueStorageFactory">
            <summary>
            Crates table storage implementations
            </summary>
        </member>
        <member name="T:Storage.Net.IModulesFactory">
            <summary>
            Module initialisation primitives
            </summary>
        </member>
        <member name="T:Storage.Net.StoragePath">
            <summary>
            Storage Path utilities
            </summary>
        </member>
        <member name="F:Storage.Net.StoragePath.PathSeparator">
            <summary>
            Character used to split paths 
            </summary>
        </member>
        <member name="F:Storage.Net.StoragePath.PathSeparatorString">
            <summary>
            Character used to split paths as a string value
            </summary>
        </member>
        <member name="F:Storage.Net.StoragePath.PathStrSeparator">
            <summary>
            Character used to split paths 
            </summary>
        </member>
        <member name="F:Storage.Net.StoragePath.RootFolderPath">
            <summary>
            Returns '/'
            </summary>
        </member>
        <member name="M:Storage.Net.StoragePath.Combine(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Combines parts of path
            </summary>
            <param name="parts"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.StoragePath.Combine(System.String[])">
            <summary>
            Combines parts of path
            </summary>
            <param name="parts"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.StoragePath.Normalize(System.String,System.Boolean)">
            <summary>
            Normalizes path. Normalisation makes sure that:
            - When path is null returns root path '/'
            - path separators are trimmed from both ends
            </summary>
            <param name="path"></param>
            <param name="includeTrailingRoot">When true, includes trailing '/' as path prefix</param>
        </member>
        <member name="M:Storage.Net.StoragePath.NormalizePart(System.String)">
            <summary>
            Normalizes path part
            </summary>
            <param name="part"></param>
            <returns></returns>
        </member>
        <member name="M:Storage.Net.StoragePath.Split(System.String)">
            <summary>
            Splits path in parts. Leading and trailing path separators are totally ignored. Note that it returns
            null if input path is null.
            </summary>
        </member>
        <member name="M:Storage.Net.StoragePath.IsRootPath(System.String)">
            <summary>
            Checks if path is root folder path
            </summary>
        </member>
        <member name="T:Storage.Net.Streaming.FixedStream">
            <summary>
            Fixes deficiencies in thrird party streaming impelmentations
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.#ctor(System.IO.Stream,System.Nullable{System.Int64},System.Action{Storage.Net.Streaming.FixedStream})">
            <summary>
            Creates a new instance
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.Parent">
            <summary>
            Gets original parent stream
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.Tag">
            <summary>
            Gets or sets an optional tag
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.CanRead">
            <summary>
            Gets parent's <see cref="P:Storage.Net.Streaming.FixedStream.CanRead"/>
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.CanSeek">
            <summary>
            Gets parent's <see cref="P:Storage.Net.Streaming.FixedStream.CanSeek"/>
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.CanWrite">
            <summary>
            Gets parent's <see cref="P:Storage.Net.Streaming.FixedStream.CanWrite"/>
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.Length">
            <summary>
            Gets stream leanth by returning either length passed in the constructor, or parent's length, in that order.
            </summary>
        </member>
        <member name="P:Storage.Net.Streaming.FixedStream.Position">
            <summary>
            Gets or sets current potision. This counter is maintained internally and parent's position is not used.
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Flush">
            <summary>
            Flushes the parent
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads from parent and updates internal position counter
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Seeks on parent
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.SetLength(System.Int64)">
            <summary>
            Sets length on parent
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes to parent and updates the internal position.
            </summary>
        </member>
        <member name="M:Storage.Net.Streaming.FixedStream.Dispose(System.Boolean)">
            <summary>
            Calls back dispose if passed in the constructor, and calls parent's dispose
            </summary>
            <param name="disposing"></param>
        </member>
    </members>
</doc>
